# createData: Create data from parameters

createData <- function(paramSet,
                       n,
                       modelType,
                       sequential=FALSE,
                       facDist=NULL,
                       errorDist=NULL,
                       indDist=NULL,
                       indLab=NULL,
                       modelBoot=FALSE,
                       realData=NULL) {
  require(MASS)
  if (modelBoot) {
    if (sequential) 
      stop("The model-based bootstrap and sequential cannot be used at the same time.")
    if (is.null(realData)) 
      stop("If the data are generated by model bootstrap, the real data are needed.")
    if (!is.null(indLab)) 
      realData <- realData[, indLab]
    if (sum(is.na(realData)) > 0) 
      stop("The model-based bootstrap is not available for data with missingness.")
  }
  if (is.null(n)) n <- nrow(realData)
  if (!is.null(errorDist)) {
    if (modelType == "Path") 
      stop("errorDist is not allowed for path analysis model. The distribution of each indicator should be specified in facDist if sequential=TRUE.")
  }
  if (!sequential & !is.null(facDist)) 
    stop("facDist is not allowed when using model-implied method in data generation")
  if (!sequential & !is.null(errorDist)) 
    stop("errorDist is not allowed when using model-implied method in data generation")
  if (sequential & !is.null(indDist)) 
    stop("indDist is not allowed when using sequential method in data generation")
  classes <- sapply(list(facDist,indDist,errorDist),class)
   
    Data <- NULL
    param <- paramSet$param
    usedParam <- NULL
    if (!is.null(paramSet$misParam)) {
        usedParam <- paramSet$misParam
    } else {
        usedParam <- param
    }

    if (modelBoot) {
        require(lavaan)
        originalData <- realData
        if (!is.null(indLab)) 
            originalData <- originalData[, indLab]
        implied <- createImpliedMACS(usedParam)
        S <- cov(originalData)
        Sigma <- implied$CM
        M <- colMeans(originalData)
        M <- matrix(rep(M, n), nrow = n, byrow = TRUE)
        Mu <- implied$M
        Mu <- matrix(rep(Mu, n), nrow = n, byrow = TRUE)
        z <- (scale(originalData, scale = FALSE) %*% (solve(sqrtSymmetricMatrix(S)) %*% sqrtSymmetricMatrix(Sigma))) + Mu
        index <- sample(1:n, replace = TRUE)
        Data <- z[index, ]
    } else {
        if (sequential) {
            if (modelType == "CFA") {
                fac <- dataGen(facDist, n, usedParam@AL, usedParam@PS)
                trueScore <- fac %*% t(usedParam@LY)
                errorScore <- dataGen(errorDist, n, usedParam@TY, usedParam@TE)
                Data <- trueScore + errorScore
            } else {
                usedParam2 <- NULL
             
                if (modelType == "Path" | modelType == "SEM") {
                  usedParam2 <- usedParam
                } else {
                  stop("Incorrect model type")
                }
                set <- findRecursiveSet(usedParam2@BE)
                iv <- set[[1]]
                fac <- dataGen(extract(facDist, iv), n, usedParam2@AL[iv], usedParam2@PS[iv, iv])
                for (i in 2:length(set)) {
                  dv <- set[[i]]
                  pred <- fac %*% t(extract(usedParam2@BE, dv, iv))
                  res <- dataGen(extract(facDist, dv), n, usedParam2@AL[dv], usedParam2@PS[dv, dv])
                  new <- pred + res
                  fac <- cbind(fac, new)
                  iv <- c(iv, set[[i]])
                }
                if (modelType == "Path") {
                  Data <- fac
                } else {
                  trueScore <- fac %*% t(usedParam2@LY)
                  errorScore <- dataGen(errorDist, n, usedParam2@TY, usedParam2@TE)
                  Data <- trueScore + errorScore
                }
            }
        } else {
            macs <- createImpliedMACS(usedParam,modelType=modelType)
            #Data <- dataGen(indDist, n, macs$M, macs$CM)
            Data <- mvrnorm(n, macs$M, macs$CM)
          }
      }
   
    varnames <- NULL
    colnames(Data) <- varnames
    Data <- as.data.frame(Data)
  ##  if (dataOnly) {
  ##         return(Data)
  ##     } else {
  ##         #out <- new("SimDataOut", modelType = modelType, data = Data, param = createFreeParameters(param), paramOut = param, misspecOut = misspec,
  ## equalCon = equalCon, n = n)
      
  ##         return(out)
  ##     }
  return(Data)
}
dataGen <- function(dataDist, n, m, cm) {
    require(MASS)
    Data <- NULL
    # Check dim(M) dim(CM) dim(copula) are equal
        require(copula)
        if (dataDist@p > 1) {
            varNotZeros <- diag(cm) != 0
            dataDist2 <- dataDist
            cm2 <- cm
            if (sum(varNotZeros) < dataDist@p) {
                dataDist2 <- extract(dataDist, which(varNotZeros))
                cm2 <- extract(cm, which(varNotZeros), which(varNotZeros))
            }
            r <- cov2cor(as.matrix(cm2))
            for (i in 1:dataDist2@p) {
                if (dataDist2@reverse[i] == TRUE) {
                  r[i, ] <- -1 * r[i, ]
                  r[, i] <- -1 * r[, i]
                }
            }
            listR <- r[lower.tri(diag(dataDist2@p))]
            CopNorm <- ellipCopula(family = "normal", dim = dataDist2@p, dispstr = "un", param = listR)
            distName <- sapply(dataDist2@dist, class)
            distName <- tolower(gsub("Sim", "", distName))
            attribute <- list()
            for (i in 1:length(dataDist2@dist)) {
                temp <- list()
                indivAttr <- slotNames(dataDist2@dist[[i]])
                for (j in 1:length(indivAttr)) {
                  temp[[j]] <- call("=", indivAttr[[j]], slot(dataDist2@dist[[i]], indivAttr[[j]]))
                }
                attribute[[i]] <- temp
            }
            Mvdc <- mvdc(CopNorm, distName, attribute)
            Data <- rmvdc(Mvdc, n)
            if (sum(varNotZeros) < dataDist@p) {
                varZeros <- diag(cm) == 0
                constant <- matrix(0, n, sum(varZeros))
                Data <- data.frame(Data, constant)
                Data[, c(which(varNotZeros), which(varZeros))] <- Data
            }
        } else if (dataDist@p == 1) {
            if (as.matrix(cm)[1, 1] == 0) {
                Data <- rep(m[1], n)
            } else {
                Data <- as.matrix(run(dataDist@dist[[1]], n = n))
            }
        } else {
            stop("when creating a data distribution object, p cannot equal 0.")
        }
        for (i in 1:dataDist@p) {
            if (dataDist@reverse[i] == TRUE) {
                meanOld <- mean(Data[, i])
                anchor <- max(Data[, i])
                datNew <- anchor - Data[, i]
                Data[, i] <- datNew - mean(datNew) + meanOld
            }
        }
        if (!is.matrix(Data)) 
            Data <- as.matrix(Data)
        if (dataDist@keepScale) {
            Data <- scale(Data)
            Data[is.na(Data)] <- 0
            fakeDat <- mvrnorm(n, m, cm)
            fakeMean <- apply(fakeDat, 2, mean)
            fakeSD <- apply(fakeDat, 2, sd)
            Data <- t(apply(Data, 1, function(y, m, s) {
                y * s + m
            }, m = fakeMean, s = fakeSD))
        }
        if (nrow(Data) == 1) 
            Data <- t(Data)
  
    return(Data)
})

simDataDist <- function(..., p = NULL, keepScale = TRUE, reverse = FALSE) {
    List <- list(...)
    check <- sapply(List, is, class2 = "VirtualDist")
    if (sum(check == FALSE) > 0) {
        stop(paste("The object(s) listed in the", paste(which(!check), collapse = ", "), "is/are not a distribution object"))
    } else {
        if (is.null(p)) 
            p <- length(List)
        if (length(reverse) == 1) 
            reverse <- rep(reverse, p)
        if (length(reverse) != p) 
            stop("Please specify the reverse option as TRUE or FALSE or the vector of TRUE/FALSE with the length of the number of the marginal distributions.")
        if (length(List) != p) {
            times <- ceiling(p/length(List))
            List <- rep(List, times)
            List <- List[1:p]
        }
        return(new("SimDataDist",p = p, dist = List, keepScale = keepScale, reverse = reverse))
    }
}

bindDist <- function(..., p = NULL, keepScale = TRUE, reverse = FALSE) {
   simDataDist(..., p = NULL, keepScale = TRUE, reverse = FALSE)
 }
