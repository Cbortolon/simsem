\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `simsem'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{SIMulated Structural Equation Modeling.}
\item[Version]\AsIs{0.5-6}
\item[Date]\AsIs{2014-5-12}
\item[Author]\AsIs{Sunthud Pornprasertmanit [aut, cre],
Patrick Miller [aut],
Alexander Schoemann [aut],
Corbin Quick [ctb],
Terry Jorgensen [ctb]}
\item[Maintainer]\AsIs{Sunthud Pornprasertmanit }\email{psunthud@ku.edu}\AsIs{}
\item[Depends]\AsIs{R(>= 3.0), lavaan(>= 0.5-16), methods}
\item[Suggests]\AsIs{parallel, Amelia, quantreg, splines, foreign, KernSmooth,
semTools, OpenMx, copula}
\item[Description]\AsIs{This package can be used to generate data using the structural equation modeling framework. This package is tailored to use those simulated data for various purposes, such as model fit evaluation, power analysis, or missing data handling and planning. Note that the OpenMx package can be obtained from the following URL: http://openmx.psyc.virginia.edu/}
\item[License]\AsIs{GPL (>= 2)}
\item[LazyLoad]\AsIs{yes}
\item[URL]\AsIs{}\url{http://www.simsem.org}\AsIs{}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{analyze}{Data analysis using the model specification}{analyze}
%
\begin{Description}\relax
Data analysis using the model specification (\code{linkS4class\{SimSem\}}) or the mx model object (\code{MxModel}). Data will be multiply imputed if the \code{miss} argument is specified. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
analyze(model, data, package="lavaan", miss=NULL, aux=NULL, group = NULL, 
	mxMixture = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] 
The simsem model template (\code{linkS4class\{SimSem\}}) or the mx model object (\code{MxModel})

\item[\code{data}] 
The target dataset 

\item[\code{package}] 
The package used in data analysis. Currently, only \code{lavaan} package can be used.

\item[\code{miss}]  
The missing object with the specification of auxiliary variable or the specification for the multiple imputation.

\item[\code{aux}]  
List of auxiliary variables

\item[\code{group}]  
A group variable. This argument is applicable only when the \code{model} argument is a \code{MxModel} object.

\item[\code{mxMixture}] 
A logical whether to the analysis model is a mixture model. This argument is applicable when \code{MxModel} is used in the \code{model} argument only.

\item[\code{...}]  
Additional arguments in the \code{\LinkA{lavaan}{lavaan}} function

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The \code{\LinkA{lavaan}{lavaan.Rdash.class}} object containing the output
\end{Value}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu})
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
Note that users can use functions provided by \code{lavaan} package (\code{\LinkA{lavaan}{lavaan}}, \code{\LinkA{cfa}{cfa}}, \code{\LinkA{sem}{sem}}, or \code{\LinkA{growth}{growth}}) if they wish to analyze data by lavaan directly. 

For the \code{OpenMx} result, users may request standardized measures and additional fit indices by the \code{\LinkA{standardizeMx}{standardizeMx}} and \code{\LinkA{fitMeasuresMx}{fitMeasuresMx}} functions in the \code{semTools} package.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

dat <- generate(CFA.Model,200)
out <- analyze(CFA.Model,dat)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{anova}{Provide a comparison of nested models and nonnested models across replications}{anova}
\aliasA{anova,SimResult-method}{anova}{anova,SimResult.Rdash.method}
%
\begin{Description}\relax
This function will provide averages of model fit statistics and indices for nested models. It will also provide average differences of fit indices and power for likelihood ratio tests of nested models.
\end{Description}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described. Currently at least two objects must be included as arguments

\item[\code{...}] 
any additional arguments, such as additional objects or for the function with result object

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame that provides the statistics described above from all parameters.
For using with \code{linkS4class\{SimResult\}}, the result is a list with two or three elements:
\begin{itemize}

\item \code{summary:} Average of fit indices across all replications
\item \code{diff:} Average of the differences in fit indices across all replications
\item \code{varyParam:} The statistical power of chi-square difference test given values of varying parameters (such as sample size or percent missing) 

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu}), 
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading1 <- matrix(0, 6, 1)
loading1[1:6, 1] <- NA
loading2 <- loading1
loading2[6,1] <- 0
LY1 <- bind(loading1, 0.7)
LY2 <- bind(loading2, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model1 <- model(LY = LY1, RPS = RPS, RTE = RTE, modelType="CFA")
CFA.Model2 <- model(LY = LY2, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
# Need to make sure that both simResult calls have the same seed!
Output1 <- sim(5, n=500, model=CFA.Model1, generate=CFA.Model1, seed=123567)
Output2 <- sim(5, n=500, model=CFA.Model2, generate=CFA.Model1, seed=123567)
anova(Output1, Output2)

# The example when the sample size is varying
Output1b <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model1, generate=CFA.Model1, seed=123567)
Output2b <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model2, generate=CFA.Model1, seed=123567)
anova(Output1b, Output2b)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bind}{Specify matrices for Monte Carlo simulation of structural equation models}{bind}
\aliasA{binds}{bind}{binds}
%
\begin{Description}\relax
Create \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}} object that specifies
\begin{enumerate}

\item Pattern of fixed/freed parameters for analysis
\item Population parameter values for data generation
\item Any model misspecification (true population parameter is different than the one specified) for these parameters. 
\end{enumerate}

Each matrix in the Lisrel-style notation is specified in this way (e.g. LY, PS, and TE) and is used to create a model analysis template and a data generation template for simulation through the \code{model} function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bind(free = NULL, popParam = NULL, misspec = NULL, symmetric = FALSE)
binds(free = NULL, popParam = NULL, misspec = NULL, symmetric = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{free}] Required matrix or vector where each element represents a fixed or freed parameter used for analysis with structural equation models. Parameters can be freed by setting the corresponding element in the matrix to \code{NA}, and can be fixed by setting the value of the element to any number (e.g. 0). Parameters can be labeled using any character string. Any labeled parameter is considered to be free, and parameters with identical labels will be constrained to equality for analysis.

\item[\code{popParam}] Optional matrix or vector of identical dimension to the free matrix whose elements contain population parameter values for data generation in simulation. For simlutation, each free parameter requires a population parameter value, which is a quoted numeric value. Parameters that don't have population values are left as empty strings.
Population parameters can also be drawn from a distribution. This is done by wrapping a call to create 1 value from an existing random generation function in quotes: e.g \code{"runif(1,0,1)","rnorm(1,0,.01)"} Every replication in the simulation will draw a parameter value from this distribution. The function checks that what is quoted is valid R.

If a random population parameter is constrained to equality in the free matrix, \emph{each drawn population parameter value will be the same.} More details on data generation is available in \code{?generate}, \code{?createData}, and \code{?draw}.

To simplify the most common case, \code{popParam} can take 1 value or distribution and create a matrix or vector that assigns that population parameter or distribution to all freed parameters. These population values are used as starting values for analysis by default.

\item[\code{misspec}] Optional matrix or vector of identical dimension to the free matrix whose elements contain population parameter values for specifying misspecification. Elements of the misspec matrix contain population parameters that are added to parameters that are fixed or have an existing population value. These parameters are also quoted numeric strings, and can optionally be drawn from distributions as described above. To simplify the most common case, misspec can take 1 value or distribution and create a matrix or vector that assigns that value or distribution to all previously specified fixed parameters. Details about misspecification are included the data generation functions.

\item[\code{symmetric}] Set as \code{TRUE} if the matrix created is symmetric (RPS/PS, RTE/TE). The function \code{binds} can also be used, which defaults to \code{symmetric = TRUE} 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Bind is the first step in the \code{bind} -> \code{model} -> \code{sim} workflow of \emph{simsem}, and this document outlines the user interface or language used to describe these simulations. This interface, while complex, enables a wide array of simulation specifications for structural equation models by building on LISREL-style parameter specifications.

In simulations supported by \emph{simsem}, a given parameter may be either fixed or freed for analysis, but may optionally also have a population value or distribution for data generation, or a value or distribution of misspecification. The purpose of bind is to stack these multiple meanings of a parameter into an object recognized by \emph{simsem}, a \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}}. Each matrix in the Lisrel notation (e.g. LY, PS, TE, BE) becomes a \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}}, and is passed to the function \code{model}, which builds the data generation template and an analysis template (a lavaan parameter table), collectively forming a \code{SimSem} object, which can be passed to the function \code{sim} for simulation.
\end{Details}
%
\begin{Value}
 \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}} object that used for model specification for analysis and data generation in simsem.
\end{Value}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}),
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}
\item \code{\LinkA{model}{model}} To combine simMatrix objects into a complete data analysis and data generation template, which is a \code{\LinkA{SimSem}{SimSem.Rdash.class}} object
\item \code{\LinkA{generate}{generate}} To generate data using the simsem template.
\item \code{\LinkA{analyze}{analyze}} To analyze real or generated data using the simsem template.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
summary(LY)

# Set both factor correlations to .05
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

# Misspecify all error covarainces
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- NA
RTE <- binds(error.cor,1,"runif(1,-.05,.05)")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{bindDist}{Create a data distribution object.}{bindDist}
%
\begin{Description}\relax
Create a data distribution object. There are two ways to specify nonnormal data-generation model. To create nonnormal data by the copula method, \code{margins} and \code{...} arguments are required. To create data by Vale and Maurelli's method, \code{skewness} and/or \code{kurtosis} arguments are required.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bindDist(margins = NULL, ..., p = NULL, keepScale = TRUE, reverse = FALSE, 
	copula = NULL, skewness = NULL, kurtosis = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{margins}] 
A character vector specifying all the marginal distributions. The characters in argument margins are used to construct density, distribution, and quantile function names. For example, \code{"norm"} can be used to specify marginal distribution, because \code{"dnorm"}, \code{"pnorm"}, and \code{"qnorm"} are all available. A user-defined distribution or other distributions can be used. For example, \code{"gl"} function in the \code{"gld"} package can be used to represent the generalized lambda distribution where \code{"dgl"}, \code{"pgl"}, and \code{"qgl"} are available. See the description of \code{margins} attribute of the \code{\LinkA{Mvdc}{Mvdc}} function for further details.

\item[\code{...}] 
A list whose each component is a list of named components, giving the parameter values of the marginal distributions. See the description of \code{paramMargins} attribute of the \code{\LinkA{Mvdc}{Mvdc}} function for further details.

\item[\code{p}] 
Number of variables. If only one distribution object is listed, the \code{p} will make the same distribution objects for all variables.

\item[\code{keepScale}] 
A vector representing whether each variable is transformed its mean and standard deviation or not. If TRUE, transform back to retain the mean and standard deviation of a variable equal to the model implied mean and standard deviation (with sampling error)

\item[\code{reverse}] 
A vector representing whether each variable is mirrored or not. If \code{TRUE}, reverse the distribution of a variable (e.g., from positive skewed to negative skewed. If one logical value is specified, it will apply to all variables.

\item[\code{copula}] 
A copula class that represents the multivariate distribution, such as \code{\LinkA{ellipCopula}{ellipCopula}}, \code{\LinkA{normalCopula}{normalCopula}}, or \code{\LinkA{archmCopula}{archmCopula}}. When this copula argument is specified, the data-transformation method from Mair, Satorra, and Bentler (2012) is used. If this copula argument is not specified, the naive Gaussian copula is used such that the correlation matrix is direct applied to the multivariate Gaussian copula. The correlation matrix will be equivalent to the Spearman's correlation (rank correlation) of the resulting data. 

\item[\code{skewness}] 
A vector of skewness of each variable. The Vale \& Maurelli (1983) method is used in data generation.

\item[\code{kurtosis}] 
A vector of (excessive) skewness of each variable. The Vale \& Maurelli (1983) method is used in data generation.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} that saves analysis result from simulate data.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Mair, P., Satorra, A., \& Bentler, P. M. (2012). Generating nonnormal multivariate data using copulas: Applications to SEM. \emph{Multivariate Behavioral Research, 47}, 547-565.

Vale, C. D. \& Maurelli, V. A. (1983) Simulating multivariate nonormal distributions. \emph{Psychometrika, 48}, 465-471.
\end{References}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for the type of resulting object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
library(copula)

# Create three-dimensional distribution by gaussian copula with 
# the following marginal distributions
#   1. t-distribution with df = 2
# 	2. chi-square distribution with df = 3
#	3. normal distribution with mean = 0 and sd = 1

# Setting the attribute of each marginal distribution
d1 <- list(df=2)
d2 <- list(df=3)
d3 <- list(mean=0, sd=1)

# Create a data distribution object by setting the names of each distribution
# and their arguments
dist <- bindDist(c("t", "chisq", "norm"), d1, d2, d3)

# Create data by using Gumbel Copula as the multivariate distribution
dist <- bindDist(c("t", "chisq", "norm"), d1, d2, d3, copula = gumbelCopula(2, dim = 3))

# Reverse the direction of chi-square distribution from positively skew to negatively skew
dist <- bindDist(c("t", "chisq", "norm"), d1, d2, d3, copula = gumbelCopula(2, dim = 3),
	reverse = c(FALSE, TRUE, FALSE))
	
# Create data based on Vale and Maurelli's method by specifying skewness and kurtosis
dist <- bindDist(skewness = c(0, -2, 2), kurtosis = c(0, 8, 4))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{coef}{Extract parameter estimates from a simulation result}{coef}
\aliasA{coef,SimResult-method}{coef}{coef,SimResult.Rdash.method}
%
\begin{Description}\relax
Extract parameter estimates from a simulation result. This function is similar to the \code{\LinkA{inspect}{inspect,SimResult.Rdash.method}} method with \code{what = "coef"}.
\end{Description}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The target \code{\LinkA{SimResult}{SimResult.Rdash.class}} object

\item[\code{improper}] 
Specify whether to include the information from the replications with improper solutions

\item[\code{nonconverged}] 
Specify whether to include the information from the nonconvergent replications

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Parameter estimates of each replication
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model, n=200)
coef(Output)
coef(Output, improper = TRUE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{combineSim}{Combine result objects}{combineSim}
%
\begin{Description}\relax
Combine result objects into a single result object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
combineSim(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Result objects, \code{\LinkA{SimResult}{SimResult.Rdash.class}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
	A combined result object
\end{Value}
%
\begin{Author}\relax
Terry Jorgensen (University of Kansas; \email{tdj@ku.edu}), 
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
Result object (\code{\LinkA{SimResult}{SimResult.Rdash.class}})
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")
Output1 <- sim(5, CFA.Model, n=200, seed=123321)
Output2 <- sim(4, CFA.Model, n=200, seed=324567)
Output3 <- sim(3, CFA.Model, n=200, seed=789987)
Output <- combineSim(Output1, Output2, Output3)
summary(Output)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{continuousCoverage}{Find coverage rate of model parameters when simulations have randomly varying parameters}{continuousCoverage}
%
\begin{Description}\relax
A function to find the coverage rate of confidence intervals in a model when one or more of the simulations parameters vary randomly across replications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
continuousCoverage(simResult, coverValue = NULL, contN = TRUE, contMCAR = FALSE, 
    contMAR = FALSE, contParam = NULL, coverParam = NULL, pred = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{simResult}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)

\item[\code{coverValue}] 
A target value used that users wish to find the coverage rate of that value (e.g., 0). If \code{NULL}, the parameter values will be used.

\item[\code{contN}] 
Logical indicating if N varies over replications.

\item[\code{contMCAR}] 
Logical indicating if the percentage of missing data that is MCAR varies over replications.

\item[\code{contMAR}] 
Logical indicating if the percentage of missing data that is MAR varies over replications.

\item[\code{contParam}] 
Vector of parameters names that vary over replications.

\item[\code{coverParam}] 
Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2"). If parameters are not specified, coverage rates for all parameters in the model will be returned.

\item[\code{pred}] 
A list of varying parameter values that users wish to find statistical power from.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In this function, the coverage (which can be 0 or 1) is regressed on randomly varying simulation parameters (e.g., sample size, percentage of missing data, or model parameters) using logistic regression. For a set of independent variables values, the predicted probability from the logistic regression equation is the predicted coverage rate.
\end{Details}
%
\begin{Value}
Data frame containing columns representing values of the randomly varying simulation parameters, and coverage rates for model parameters of interest.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Specify Sample Size by n
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Find the coverage rates of all combinations of different sample size and percent MCAR missing
Ccover <- continuousCoverage(Output, contN = TRUE, contMCAR = TRUE)
Ccover

# Find the coverage rates of parameter estimates when sample size is 200 
# and percent MCAR missing is 0.3
Ccover2 <- continuousCoverage(Output, coverValue=0, contN = TRUE, contMCAR = TRUE, 
     pred=list(N = 200, pmMCAR = 0.3))
Ccover2

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{continuousPower}{Find power of model parameters when simulations have randomly varying parameters}{continuousPower}
%
\begin{Description}\relax
A function to find the power of  parameters in a model when one or more of the simulations parameters vary randomly across replications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
continuousPower(simResult, contN = TRUE, contMCAR = FALSE, contMAR = FALSE, 
	contParam = NULL, alpha = .05, powerParam = NULL, pred = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{simResult}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)

\item[\code{contN}] 
Logical indicating if N varies over replications.

\item[\code{contMCAR}] 
Logical indicating if the percentage of missing data that is MCAR varies over replications.

\item[\code{contMAR}] 
Logical indicating if the percentage of missing data that is MAR varies over replications.

\item[\code{contParam}] 
Vector of parameters names that vary over replications.

\item[\code{alpha}] 
Alpha level to use for power analysis.

\item[\code{powerParam}] 
Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2"). If parameters are not specified, power for all parameters in the model will be returned.

\item[\code{pred}] 
A list of varying parameter values that users wish to find statistical power from.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A common use of simulations is to conduct power analyses, especially when using SEM (Muthen \& Muthen, 2002). Here, researchers select values for each parameter and a sample size and run a simulation to determine power in those conditions (the proportion of generated datasets in which a particular parameter of interest is significantly different from zero). To evaluate power at multiple sample sizes, one simulation for each sample size must be run. By continuously varying sample size across replications, only a single simulation is needed. In this simulation, the sample size for each replication varies randomly across plausible sample sizes (e.g., sample sizes between 200 and 500). For each replication, the sample size and significance of each parameter (0 = not significant, 1 = significant) are recorded. When the simulation is complete, parameter significance is regressed on sample size using logistic regression. For a given sample size, the predicted probability from the logistic regression equation is the power to detect an effect at that sample size. This approach can be extended to other randomly varying simulation parameters such as the percentage of missing data, and model parameters.
\end{Details}
%
\begin{Value}
Data frame containing columns representing values of the randomly varying simulation parameters, and power for model parameters of interest.
\end{Value}
%
\begin{Author}\relax
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu}), Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Muthen, L. K., \& Muthen, B. O. (2002). How to use a Monte Carlo study to decide on sample size and determine power. \emph{Structural Equation Modeling, 4,} 599-620.
\end{References}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Specify Sample Size by n
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")
dat <- generate(CFA.Model, 50)
out <- analyze(CFA.Model, dat)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Find the power of all combinations of different sample size and percent MCAR missing
Cpow <- continuousPower(Output, contN = TRUE, contMCAR = TRUE)
Cpow

# Find the power of parameter estimates when sample size is 200 and percent MCAR missing is 0.3
Cpow2 <- continuousPower(Output, contN = TRUE, contMCAR = TRUE, pred=list(N = 200, pmMCAR = 0.3))
Cpow2

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{createData}{Create data from a set of drawn parameters.}{createData}
%
\begin{Description}\relax
This function can be used to create data from a set of parameters created from \code{\LinkA{draw}{draw}}, called a codeparamSet. This function is used internally to create data, and is available publicly for accessibility and debugging.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
createData(paramSet, n, indDist=NULL, sequential=FALSE, facDist=NULL, 
errorDist=NULL, saveLatentVar = FALSE, indLab=NULL, modelBoot=FALSE, 
realData=NULL, covData=NULL, empirical = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{paramSet}] 
Set of drawn parameters from \code{\LinkA{draw}{draw}}.

\item[\code{n}] 
Integer of desired sample size.

\item[\code{indDist}] 
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when \code{sequential} is \code{FALSE}.

\item[\code{sequential}] 
If \code{TRUE}, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If \code{FALSE}, create data directly from model-implied mean and covariance of indicators.

\item[\code{facDist}] 
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when \code{sequential} is \code{TRUE}.

\item[\code{errorDist}] 
An object or list of objects of type \code{SimDataDist} indicating the distribution of errors. If a single \code{SimDataDist} is specified, each error will be genrated with that distribution.

\item[\code{saveLatentVar}]  
If \code{TRUE}, the generated latent variable scores and measurement error scores are also provided as the \code{"latentVar"} attribute of the generated data by the following line: \code{attr(generatedData, "latentVar")}. The \code{sequential} argument must be \code{TRUE} in order to use this option.

\item[\code{indLab}] 
A vector of indicator labels. When not specified, the variable names are \code{x1, x2, ... xN}.

\item[\code{modelBoot}] 
When specified, a model-based bootstrap is used for data generation. See details for further information. This argument requires real data to be passed to \code{readData}.

\item[\code{realData}] 
A data.frame containing real data. The data generated will follow the distribution of this data set.

\item[\code{covData}]  
A data.frame containing covariate data, which can have any distributions. This argument is required when users specify \code{GA} or \code{KA} matrices in the model template (\code{\LinkA{SimSem}{SimSem.Rdash.class}}).

\item[\code{empirical}]  
Logical. If \code{TRUE}, the specified parameters are treated as sample statistics and data are created to get the specified sample statistics. This argument is applicable when multivariate normal distribution is specified only.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function will use the modified \code{mvrnorm} function (from the MASS package) by Paul E. Johnson  to create data from model implied covariance matrix if the data distribution object (\code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}}) is not specified. The modified function is just a small modification from the original \code{mvrnorm} function such that the data generated with the sample sizes of n and n + k (where k > 0) will be replicable in the first n rows.

It the data distribution object is specified, either the copula model or the Vale and Maurelli's method is used. For the copula approach, if the \code{copula} argument is not specified in the data distribution object, the naive Gaussian copula is used. The correlation matrix is direct applied to the multivariate Gaussian copula. The correlation matrix will be equivalent to the Spearman's correlation (rank correlation) of the resulting data. If the \code{copula} argument is specified, such as \code{\LinkA{ellipCopula}{ellipCopula}}, \code{\LinkA{normalCopula}{normalCopula}}, or \code{\LinkA{archmCopula}{archmCopula}}, the data-transformation method from Mair, Satorra, and Bentler (2012) is used. In brief, the data (\eqn{X}{}) are created from the multivariate copula. The covariance from the generated data is used as the starting point (\eqn{S}{}). Then, the target data (\eqn{Y}{}) with the target covariance as model-implied covariance matrix (\eqn{\Sigma_0}{}) can be created:

\deqn{ Y = XS^{-1/2}\Sigma^{1/2}_0. }{}

See \code{\LinkA{bindDist}{bindDist}} for further details. For the Vale and Maurelli's (1983) method, the code is brought from the \code{lavaan} package.

For the model-based bootstrap, the transformation proposed by Yung \& Bentler (1996) is used. This procedure is the expansion from the Bollen and Stine (1992) bootstrap including a mean structure. The model-implied mean vector and covariance matrix with trivial misspecification will be used in the model-based bootstrap if \code{misspec} is specified. See page 133 of Bollen and Stine (1992) for a reference. 

Internally, parameters are first drawn, and data is then created from these parameters. Both of these steps are available via the \code{\LinkA{draw}{draw}} and \code{\LinkA{createData}{createData}} functions respectively.
\end{Details}
%
\begin{Value}
A data.frame containing simulated data from the data generation template. A variable "group" is appended indicating group membership.
\end{Value}
%
\begin{Author}\relax
	
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}). The original code of \code{mvrnorm} function is based on the \code{MASS} package slightly modified by Paul E. Johnson. The code for data-transformation in multivariate copula is based on Mair et al. (2012) article. The code for Vale and Maurelli (1983) is slightly modified from the function provided in the \code{lavaan} package.
\end{Author}
%
\begin{References}\relax
Bollen, K. A., \& Stine, R. A. (1992). Bootstrapping goodness-of-fit measures in structural equation models. \emph{Sociological Methods and Research, 21,} 205-229.

Mair, P., Satorra, A., \& Bentler, P. M. (2012). Generating nonnormal multivariate data using copulas: Applications to SEM. \emph{Multivariate Behavioral Research, 47}, 547-565.

Vale, C. D. \& Maurelli, V. A. (1983) Simulating multivariate nonormal distributions. \emph{Psychometrika, 48}, 465-471.

Yung, Y.-F., \& Bentler, P. M. (1996). Bootstrapping techniques in analysis of mean and covariance structures. In G. A. Marcoulides \& R. E. Schumacker (Eds.), \emph{Advanced structural equation modeling: Issues and techniques} (pp. 195-226). Mahwah, NJ: Erlbaum.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Draw a parameter set for data generation.
param <- draw(CFA.Model)

# Generate data from the first group in the paramList.
dat <- createData(param[[1]], n = 200) 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{draw}{Draw parameters from a \code{\LinkA{SimSem}{SimSem.Rdash.class}} object.}{draw}
%
\begin{Description}\relax
This function draws parameters from a \code{\LinkA{SimSem}{SimSem.Rdash.class}} template, for debugging or other use. Used internally to create data. Data can be created in one step from a \code{SimSem} object using \code{\LinkA{generate}{generate}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
draw(model, maxDraw=50, misfitBounds=NULL, averageNumMisspec=FALSE, 
optMisfit = NULL, optDraws = 50, misfitType = "f0", createOrder = c(1, 2, 3),
covData = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] 
A \code{\LinkA{SimSem}{SimSem.Rdash.class}} object. 

\item[\code{maxDraw}] 
Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).

\item[\code{misfitBounds}] 
Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.

\item[\code{averageNumMisspec}] 
If \code{TRUE}, the provided fit will be divided by the number of misspecified parameters. 

\item[\code{optMisfit}] 
Character vector of either "min" or "max" indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in "optDraws" that has either the maximum or minimum misfit of the given misfit type will be returned.

\item[\code{optDraws}] 
Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.

\item[\code{misfitType}] 
Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be "f0", "rmsea", "srmr", or "all". 

\item[\code{createOrder}] 
The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, \code{c(1, 2, 3)} is to apply constraints first, then add the misspecification, and finally fill all parameters. 

\item[\code{covData}]  
A data.frame containing covariate data, which can have any distributions. This argument is required when users specify \code{GA} or \code{KA} matrices in the model template (\code{\LinkA{SimSem}{SimSem.Rdash.class}}).

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Nested list of drawn parameters in the form \code{[[Group]][[param,misspec,misOnly]][[SimMatrix]]}. E.g. The LY parameter matrix of the first group would be indexed as \code{obj[[1]]\$param\$LY}.
The values in \$param are the raw parameter values with no misspecification. The values in \$misspec are raw parameter values + misspecification. The values in \$misOnly are only the misspecification values. 
\end{Value}
%
\begin{Author}\relax
	
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}) 
\end{Author}
%
\begin{SeeAlso}\relax
		
\code{\LinkA{createData}{createData}} To generate random data using a set of parameters from \code{\LinkA{draw}{draw}}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Draw a parameter set for data generation.
param <- draw(CFA.Model)

# Example of Multiple Group Model with Weak Invariance

loading.in <- matrix(0, 6, 2)
loading.in[1:3, 1] <- c("load1", "load2", "load3")
loading.in[4:6, 2] <- c("load4", "load5", "load6")
mis <- matrix(0,6,2)
mis[loading.in == "0"] <- "runif(1, -0.1, 0.1)"
LY.in <- bind(loading.in, "runif(1, 0.7, 0.8)", mis)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VTE <- bind(rep(NA, 6), 0.51)

VPS1 <- bind(rep(1, 2))

VPS2 <- bind(rep(NA, 2), c(1.1, 1.2))

# Inequality constraint
script <- "
sth := load1 + load2 + load3
load4 == (load5 + load6) / 2
load4 > 0
load5 > 0
sth2 := load1 - load2
"

# Model Template
weak <- model(LY = LY.in, RPS = RPS, VPS=list(VPS1, VPS2), RTE = RTE, VTE=VTE, ngroups=2, 
     modelType = "CFA", con=script)

# Constraint --> Misspecification --> Fill Parameters
draw(weak, createOrder=c(1, 2, 3))

# Constraint --> Fill Parameters --> Misspecification 
draw(weak, createOrder=c(1, 3, 2))

# Misspecification --> Constraint --> Fill Parameters
draw(weak, createOrder=c(2, 1, 3))

# Misspecification --> Fill Parameters --> Constraint
draw(weak, createOrder=c(2, 3, 1))

# Fill Parameters --> Constraint --> Misspecification
draw(weak, createOrder=c(3, 1, 2))

# Fill Parameters --> Misspecification --> Constraint
draw(weak, createOrder=c(3, 2, 1))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{estmodel}{Shortcut for data analysis template for simulation.}{estmodel}
\methaliasA{estmodel.cfa}{estmodel}{estmodel.cfa}
\methaliasA{estmodel.path}{estmodel}{estmodel.path}
\methaliasA{estmodel.sem}{estmodel}{estmodel.sem}
%
\begin{Description}\relax
Creates a data analysis template (lavaan parameter table) for simulations with structural equation models based on Y-side LISREL design matrices. Each corresponds to a LISREL matrix, but must be a matrix or a vector. In addition to the usual Y-side matrices in LISREL, both PS and TE can be specified using correlations (RPS, RTE) and scaled by a vector of residual variances (VTE, VPS) or total variances (VY, VE). Multiple groups are supported by passing lists of matrices or vectors to arguments, or by specifying the number of groups. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
estmodel(LY = NULL, PS = NULL, RPS = NULL, TE = NULL, RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, 
	MY = NULL, ME = NULL, KA = NULL, GA = NULL, modelType, indLab = NULL, 
	facLab = NULL, covLab = NULL, groupLab = "group", ngroups = 1, con = NULL)
estmodel.cfa(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, VTE = NULL, 
	VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, 
	KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
estmodel.path(PS = NULL, RPS = NULL, BE = NULL, VPS = NULL, VE = NULL, AL = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1,con = NULL)
estmodel.sem(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{LY}] 
Factor loading matrix from endogenous factors to Y indicators (need to be a matrix or a list of matrices).

\item[\code{PS}] 
Residual covariance matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{RPS}] 
Residual correlation matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{TE}] 
Measurement error covariance matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{RTE}] 
Measurement error correlation matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{BE}] 
Regression coefficient matrix among endogenous factors (need to be a matrix or a list of matrices).

\item[\code{VTE}] 
Measurement error variance of indicators (need to be a vector or a list of vectors).

\item[\code{VY}] 
Total variance of indicators (need to be a vector or a list of vectors). NOTE: Either measurement error variance or indicator variance is specified. Both cannot be simultaneously specified.

\item[\code{VPS}] 
Residual variance of factors (need to be a vector or a list of vectors).

\item[\code{VE}] 
Total variance of of factors (need to be a vector or a list of vectors). NOTE: Either residual variance of factors or total variance of factors is specified. Both cannot be simulatneously specified.
 
\item[\code{TY}] 
Measurement intercepts of Y indicators. (need to be a vector or a list of vectors).

\item[\code{AL}] 
Endogenous factor intercept (need to be a vector or a list of vectors).

\item[\code{MY}] 
Overall Y indicator means. (need to be a vector or a list of vectors). NOTE: Either measurement intercept of indicator mean can be specified. Both cannot be specified simultaneously.

\item[\code{ME}] 
Total mean of endogenous factors (need to be a vector or a list of vectors). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.

\item[\code{KA}] 
Regression coefficient matrix from covariates to indicators (need to be a matrix or a list of matrices). KA is needed when (fixed) exogenous covariates are needed only.

\item[\code{GA}] 
Regression coefficient matrix from covariates to factors (need to be a matrix or a list of matrices). GA is needed when (fixed) exogenous covariates are needed only.

\item[\code{modelType}] 
"CFA", "Sem", or "Path". This is specified to ensure that the analysis and data generation template created based on specified matrices in model correspond to what the user intends.

\item[\code{indLab}] 
Character vector of indicator labels. If left blank, automatic labels will be generated as  \code{y1}, \code{y2}, ... \code{yy}.

\item[\code{facLab}]  
Character vector of factor labels. If left blank, automatic labels will be generated as \code{f1}, \code{f2}, ... \code{ff}

\item[\code{covLab}]  
Character vector of covariate labels. If left blank, automatic labels will be generated as \code{z1}, \code{z2}, ... \code{zz}

\item[\code{groupLab}] 
Character of group-variable label (not the names of each group). If left blank, automatic labels will be generated as \code{group}

\item[\code{ngroups}] 
Integer. Number of groups for data generation, defaults to 1. If larger than one, all specified matrices will be repeated for each additional group. If any matrix argument is a list, the length of this list will be the number of groups and ngroups is ignored.

\item[\code{con}] 
Additional parameters (phantom variables), equality constraints, and inequality constraints that users wish to specify in the model. The additional parameters are specified in lavaan syntax. The allowed operator are ":=" (is defined as), "==" (is equal to), "<" (is less than), and ">" (is greater than). Names used in the syntax are the labels defined on free parameters in the model except that the left-handed-side name of ":=" is a new parameter name. On the right hand side of all operators, any mathematical expressions are allowed, e.g., \code{"newparam := (load1 + load2 + load3)/3"}. For the "<" and ">" operators in data generation, if the parameters relation is not hold (e.g., the left hand side is less than the right hand side in the ">" operator), the left hand side parameters will be changed such that the relation holds with a very small difference (i.e., 0.000001). For example, in "load1 > load2", if load1 is 0.5 and load2 is 0.6, load1 will be changed to 0.6 + 0.000001 = 0.600001. 

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function contains default settings:

For \code{modelType="CFA"}, \code{LY} is required. As the default, the on-diagonal elements of \code{PS} are fixed as 1 and the off-diagonal elements of \code{PS} are freely estimated. The off-diagonal elements of \code{TE} are freely estimated and the off-diagonal elements of \code{TE} are fixed to 0. The \code{AL} elements are fixed to 0. The \code{TY} elements are freely estimated.

For \code{modelType="Path"}, \code{BE} is required. As the default, the on-diagonal elements of \code{PS} are freely estimated, the off-diagonal elements between exogenous variables (covariance between exogenous variables) are freely estimated, and the other off-diagonal elements are fixed to 0. The \code{AL} elements are freely estimated. 

For \code{modelType="SEM"}, \code{LY} and \code{BE} are required. As the default, the on-diagonal elements of \code{PS} are fixed to 1, the off-diagonal elements between exogenous factors (covariance between exogenous factors) are freely estimated, and the other off-diagonal elements are fixed to 0. The off-diagonal elements of \code{TE} are freely estimated and the off-diagonal elements of \code{TE} are fixed to 0. The \code{AL} elements are fixed to 0. The \code{TY} elements are freely estimated.

The \code{estmodel.cfa}, \code{estmodel.path}, and \code{estmodel.sem} are the shortcuts for the \code{estmodel} function when \code{modelType} are \code{"CFA"}, \code{"Path"}, and \code{"SEM"}, respectively.
\end{Details}
%
\begin{Value}
\code{SimSem} object that contains the data generation template (\code{@dgen}) and analysis template (\code{@pt}).
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{model}{model}} To build data generation and data analysis template for simulation.
\item \code{\LinkA{sim}{sim}} For simulations using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{generate}{generate}} To generate data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{analyze}{analyze}} To analyze real or generated data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{draw}{draw}} To draw parameters using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 12, 4)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[7:9, 3] <- NA
loading[10:12, 4] <- NA

CFA.Model <- estmodel(LY = loading, modelType = "CFA")

path <- matrix(0, 4, 4)
path[3, 1:2] <- NA
path[4, 3] <- NA
Path.Model <- estmodel(BE = path, modelType = "Path")

SEM.Model <- estmodel(BE = path, LY = loading, modelType="SEM")

# Shortcut
CFA.Model <- estmodel.cfa(LY = loading)
Path.Model <- estmodel.path(BE = path)
SEM.Model <- estmodel.sem(BE = path, LY = loading)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{exportData}{Export data sets for analysis with outside SEM program.}{exportData}
%
\begin{Description}\relax
This function can be used to export data created from a set of parameters created from \code{\LinkA{draw}{draw}}, called a codeparamSet. This function can export data to be analyzed with either Mplus or LISREL.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
exportData(nRep, model, n, program = "Mplus", fileStem = "sim", miss = NULL, 
	missCode = -999, datafun=NULL, pmMCAR = NULL, pmMAR = NULL, facDist = NULL, 
	indDist = NULL, errorDist = NULL, sequential = FALSE, modelBoot = FALSE, 
	realData = NULL, maxDraw = 50, misfitType = "f0", misfitBounds = NULL, 
	averageNumMisspec = NULL, optMisfit=NULL, optDraws = 50, seed = 123321, 
	silent = FALSE, multicore = FALSE, numProc = NULL,  params = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nRep}] 
Number of replications. Users can specify as \code{NULL} and specify \code{n}, \code{pmMCAR}, and \code{pmMAR}

\item[\code{model}] 
\code{\LinkA{SimSem}{SimSem.Rdash.class}} object created by \code{\LinkA{model}{model}}. Will be used to generate data and analyze it.

\item[\code{n}] 
Sample size. This argument is not necessary except the user wish to vary sample size across replications. The sample size here is a vector of sample size in integers. For the random distribution object, if the resulting value has decimal, the value will be rounded. 

\item[\code{program}] 
Statistical program that will be used to analyze data. Currently only Mplys and LISREL are supported.

\item[\code{fileStem}] 
The stem of the filename(s) for file(s) output. For example, a fileStem of "sim" will result in files named sim1.dat, sim2.dat, etc.

\item[\code{miss}] 
Missing data handling template, created by the function \code{\LinkA{miss}{miss}}.

\item[\code{missCode}] 
Missing data code, NA will be replaced by this value for all missing values in exported data.

\item[\code{datafun}] 
Function to be applied to generated data set at each replication.

\item[\code{pmMCAR}] 
The percent completely missing at random. This argument is not necessary except the user wish to vary percent missing completely at random across replications. The \code{pmMCAR} here is a vector of percent missing, which the values can be in between 0 and 1 only. The specification of \code{objMissing} is not needed (but is needed if users wish to specify complex missing value data generation or wish to use multiple imputation). 

\item[\code{pmMAR}] 
The percent missing at random. This argument is not necessary except the user wish to vary percent missing at random across replications. The \code{pmMAR} here is a vector of percent missing, which the values can be in between 0 and 1 only. The specification of \code{objMissing} is not needed (but is needed if users wish to specify complex missing value data generation or wish to use multiple imputation). 


\item[\code{facDist}]  
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when \code{sequential} is \code{TRUE}.

\item[\code{indDist}]  
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when \code{sequential} is \code{FALSE}.

\item[\code{errorDist}]  
An object or list of objects of type \code{SimDataDist} indicating the distribution of errors. If a single \code{SimDataDist} is specified, each error will be genrated with that distribution.

\item[\code{sequential}]  
If \code{TRUE}, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If \code{FALSE}, create data directly from model-implied mean and covariance of indicators.

\item[\code{modelBoot}]  
When specified, a model-based bootstrap is used for data generation. See \code{\LinkA{draw}{draw}} for further information. This argument requires real data to be passed to \code{realData}.

\item[\code{realData}]  
A data.frame containing real data. The data generated will follow the distribution of this data set.

\item[\code{maxDraw}]  
Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).

\item[\code{misfitType}]  
Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be "f0", "rmsea", "srmr", or "all". 

\item[\code{misfitBounds}]  
Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.

\item[\code{averageNumMisspec}]  
If \code{TRUE}, the provided fit will be divided by the number of misspecified parameters. 

\item[\code{optMisfit}]  
Character vector of either "min" or "max" indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in "optDraws" that has either the maximum or minimum misfit of the given misfit type will be returned.

\item[\code{optDraws}]  
Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.

\item[\code{seed}]  
Random number seed. Reproducibility across multiple cores or clusters is ensured using R'Lecuyer package.

\item[\code{silent}]  
If \code{TRUE}, suppress warnings.

\item[\code{multicore}]  
Use multiple processors within a computer. Specify as TRUE to use it.

\item[\code{numProc}]  
Number of processors for using multiple processors. If it is \code{NULL}, the package will find the maximum number of processors.

\item[\code{params}]  
If \code{TRUE}, the parameters from each replication will be returned.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Text files saved to the current working directory. If \code{program} = "Mplus" one file is output for each replication, and an extra file is output with the names of all saved data sets (this file can be used with the MONTECARLO command in Mplus). If \code{program} = "LISREL" one file is output with each replication stacked on top of the next (this file can be used with the RP command in LISREL). If \code{program} = \code{TRUE}, a list of parameter values for each replication is returned.
\end{Value}
%
\begin{Author}\relax
	
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu}) 
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

## Export 20 replications to an external data file (not run).
#exportData(20, CFA.Model, 200)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findCoverage}{Find a value of independent variables that provides a given value of coverage rate }{findCoverage}
%
\begin{Description}\relax
Find a value of independent variable that provides a given value of coverage rate. If there are more than one varying parameters, this function will find the value of the target varying parameters given the values of the other varying parameters.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findCoverage(coverTable, iv, target)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{coverTable}] 
A \code{data.frame} providing varying parameters and coverage rates of each parameter. This table is obtained by \code{\LinkA{getPower}{getPower}} or \code{\LinkA{continuousPower}{continuousPower}} function.

\item[\code{iv}] 
The target varying parameter that users would like to find the value providing a given power from. This argument can be specified as the index of the target column or the name of target column (i.e., \code{"iv.N"} or \code{"N"})

\item[\code{target}] 
The target coverage rate

\end{ldescription}
\end{Arguments}
%
\begin{Value}
There are five possible types of values provided:
\begin{itemize}

\item \emph{Value} The varying parameter value that provides the coverage rate just under the specified coverage rate (the adjacent value of varying parameter provides over power than the specified power value).
\item \emph{Minimum value} The minimum value has already provided the low coverage rate (way under the specified coverage rate). The value of varying parameters that provides exact coverage rate may be lower than the minimum value. The example of varying parameter that can provides the minimum value is sample size.
\item \emph{Maximum value} The maximum value has already provided the low coverage rate (way under the specified coverage rate). The value of varying parameters that provides exact desired power may be higher than the maximum value. The example of varying parameter that can provides the maximum value is percent missing.
\item \code{NA} There is no value in the domain of varying parameters that provides the coverage rate lower than the desired coverage rate.
\item \code{Inf} The coverage rate of all values in the varying parameters is 0 (specifically more than 0.0001) and any values of the varying parameters can be picked and still provide enough power.

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{getCoverage}{getCoverage}} to find the coverage rate of parameter estimates		
\item \code{\LinkA{continuousCoverage}{continuousCoverage}} to find the coverage rate of parameter estimates for the result object (\code{linkS4class\{SimResult\}}) with varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Specify Sample Size by n
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.4)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))

# Find the power of all possible combination of N and pmMCAR
cover <- getCoverage(Output, coverValue = 0)

# Find the sample size that provides the power of 0.8
findCoverage(cover, "N", 0.20)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findFactorIntercept}{Find factor intercept from regression coefficient matrix and factor total means}{findFactorIntercept}
%
\begin{Description}\relax
Find factor intercept from regression coefficient matrix and factor total means for latent variable models. In the path analysis model, this function will find indicator intercept from regression coefficient and indicator total means.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFactorIntercept(beta, factorMean = NULL, gamma = NULL, covmean = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
Regression coefficient matrix among factors

\item[\code{factorMean}] 
A vector of total (model-implied) factor (indicator) means. The default is that all total factor means are 0.

\item[\code{gamma}] 
Regression coefficient matrix from covariates (column) to factors (rows)

\item[\code{covmean}] 
A vector of covariate means.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of factor (indicator) intercepts
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- 0.6
path[5, 2] <- path[8, 5] <- 0.6
path[6, 3] <- path[9, 6] <- 0.6
path[5, 1] <- path[8, 4] <- 0.4
path[6, 2] <- path[9, 5] <- 0.4
factorMean <- c(5, 2, 3, 0, 0, 0, 0, 0, 0)
findFactorIntercept(path, factorMean)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findFactorMean}{Find factor total means from regression coefficient matrix and factor intercept}{findFactorMean}
%
\begin{Description}\relax
Find factor total means from regression coefficient matrix and factor intercepts for latent variable models. In the path analysis model, this function will find indicator total means from regression coefficient and indicator intercept.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFactorMean(beta, alpha = NULL, gamma = NULL, covmean = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
Regression coefficient matrix among factors

\item[\code{alpha}] 
Factor (indicator) intercept. The default is that all factor intercepts are 0.

\item[\code{gamma}] 
Regression coefficient matrix from covariates (column) to factors (rows)

\item[\code{covmean}] 
A vector of covariate means.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of factor (indicator) total means
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- 0.6
path[5, 2] <- path[8, 5] <- 0.6
path[6, 3] <- path[9, 6] <- 0.6
path[5, 1] <- path[8, 4] <- 0.4
path[6, 2] <- path[9, 5] <- 0.4
intcept <- c(5, 2, 3, 0, 0, 0, 0, 0, 0)
findFactorMean(path, intcept)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findFactorResidualVar}{Find factor residual variances from regression coefficient matrix, factor (residual) correlations, and total factor variances}{findFactorResidualVar}
%
\begin{Description}\relax
Find factor residual variances from regression coefficient matrix, factor (residual) correlation matrix, and total factor variances  for latent variable models. In the path analysis model, this function will find indicator residual variances from regression coefficient, indicator (residual) correlation matrix, and total indicator variances. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFactorResidualVar(beta, corPsi, totalVarPsi = NULL, gamma = NULL, covcov = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
Regression coefficient matrix among factors

\item[\code{corPsi}] 
Factor or indicator residual correlations.

\item[\code{totalVarPsi}] 
Factor or indicator total variances. The default is that all factor or indicator total variances are 1. 

\item[\code{gamma}] 
Regression coefficient matrix from covariates (column) to factors (rows)

\item[\code{covcov}] 
A covariance matrix among covariates

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of factor (indicator) residual variances
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- 0.6
path[5, 2] <- path[8, 5] <- 0.6
path[6, 3] <- path[9, 6] <- 0.6
path[5, 1] <- path[8, 4] <- 0.4
path[6, 2] <- path[9, 5] <- 0.4
facCor <- diag(9)
facCor[1, 2] <- facCor[2, 1] <- 0.4
facCor[1, 3] <- facCor[3, 1] <- 0.4
facCor[2, 3] <- facCor[3, 2] <- 0.4
totalVar <- rep(1, 9)
findFactorResidualVar(path, facCor, totalVar)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findFactorTotalCov}{Find factor total covariance from regression coefficient matrix, factor residual covariance}{findFactorTotalCov}
%
\begin{Description}\relax
Find factor total covariances from regression coefficient matrix, factor residual covariance matrix. The residual covaraince matrix might be derived from factor residual correlation, total variance, and error variance. This function can be applied for path analysis model as well. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFactorTotalCov(beta, psi = NULL, corPsi = NULL, totalVarPsi = NULL, 
    errorVarPsi = NULL, gamma = NULL, covcov = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
Regression coefficient matrix among factors

\item[\code{psi}] 
Factor or indicator residual covariances. This argument can be skipped if factor residual correlation and either total variances or error variances are specified.

\item[\code{corPsi}] 
Factor or indicator residual correlation. This argument must be specified with total variances or error variances.

\item[\code{totalVarPsi}] 
Factor or indicator total variances.

\item[\code{errorVarPsi}] 
Factor or indicator residual variances. 

\item[\code{gamma}] 
Regression coefficient matrix from covariates (column) to factors (rows)

\item[\code{covcov}] 
A covariance matrix among covariates

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of factor (model-implied) total covariance
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- 0.6
path[5, 2] <- path[8, 5] <- 0.6
path[6, 3] <- path[9, 6] <- 0.6
path[5, 1] <- path[8, 4] <- 0.4
path[6, 2] <- path[9, 5] <- 0.4
facCor <- diag(9)
facCor[1, 2] <- facCor[2, 1] <- 0.4
facCor[1, 3] <- facCor[3, 1] <- 0.4
facCor[2, 3] <- facCor[3, 2] <- 0.4
residualVar <- c(1, 1, 1, 0.64, 0.288, 0.288, 0.64, 0.29568, 0.21888)
findFactorTotalCov(path, corPsi=facCor, errorVarPsi=residualVar)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findFactorTotalVar}{Find factor total variances from regression coefficient matrix, factor (residual) correlations, and factor residual variances}{findFactorTotalVar}
%
\begin{Description}\relax
Find factor total variances from regression coefficient matrix, factor (residual) correlation matrix, and factor residual variances  for latent variable models. In the path analysis model, this function will find indicator total variances from regression coefficient, indicator (residual) correlation matrix, and indicator residual variances. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findFactorTotalVar(beta, corPsi, residualVarPsi, gamma = NULL, covcov = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
Regression coefficient matrix among factors

\item[\code{corPsi}] 
Factor or indicator residual correlations.

\item[\code{residualVarPsi}] 
Factor or indicator residual variances. 

\item[\code{gamma}] 
Regression coefficient matrix from covariates (column) to factors (rows)

\item[\code{covcov}] 
A covariance matrix among covariates

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of factor (indicator) total variances
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- 0.6
path[5, 2] <- path[8, 5] <- 0.6
path[6, 3] <- path[9, 6] <- 0.6
path[5, 1] <- path[8, 4] <- 0.4
path[6, 2] <- path[9, 5] <- 0.4
facCor <- diag(9)
facCor[1, 2] <- facCor[2, 1] <- 0.4
facCor[1, 3] <- facCor[3, 1] <- 0.4
facCor[2, 3] <- facCor[3, 2] <- 0.4
residualVar <- c(1, 1, 1, 0.64, 0.288, 0.288, 0.64, 0.29568, 0.21888)
findFactorTotalVar(path, facCor, residualVar)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findIndIntercept}{Find indicator intercepts from factor loading matrix, total factor mean, and indicator mean.}{findIndIntercept}
%
\begin{Description}\relax
Find indicator (measurement) intercepts from a factor loading matrix, total factor mean, and indicator mean.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findIndIntercept(lambda, factorMean = NULL, indicatorMean = NULL, 
	kappa = NULL, covmean = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lambda}] 
Factor loading matrix

\item[\code{factorMean}] 
Total (model-implied) mean of factors. As a default, all total factor means are 0.

\item[\code{indicatorMean}] 
Total indicator means. As a default, all total indicator means are 0.

\item[\code{kappa}] 
Regression coefficient matrix from covariates (column) to indicators (rows)

\item[\code{covmean}] 
A vector of covariate means.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of indicator (measurement) intercepts.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- c(0.6, 0.7, 0.8)
loading[4:6, 2] <- c(0.6, 0.7, 0.8)
facMean <- c(0.5, 0.2)
indMean <- rep(1, 6)
findIndIntercept(loading, facMean, indMean)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findIndMean}{Find indicator total means from factor loading matrix, total factor mean, and indicator intercept.}{findIndMean}
%
\begin{Description}\relax
Find indicator total means from a factor loading matrix, total factor means, and indicator (measurement) intercepts.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findIndMean(lambda, factorMean = NULL, tau = NULL, kappa = NULL, 
	covmean = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lambda}] 
Factor loading matrix

\item[\code{factorMean}] 
Total (model-implied) mean of factors. As a default, all total factor means are 0.

\item[\code{tau}] 
Indicator (measurement) intercepts. As a default, all intercepts are 0.

\item[\code{kappa}] 
Regression coefficient matrix from covariates (column) to indicators (rows)

\item[\code{covmean}] 
A vector of covariate means.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of indicator total means.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- c(0.6, 0.7, 0.8)
loading[4:6, 2] <- c(0.6, 0.7, 0.8)
facMean <- c(0.5, 0.2)
intcept <- rep(0, 6)
findIndMean(loading, facMean, intcept)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findIndResidualVar}{Find indicator residual variances from factor loading matrix, total factor covariance, and total indicator variances.}{findIndResidualVar}
%
\begin{Description}\relax
Find indicator (measurement) residual variances from a factor loading matrix, total factor covariance matrix, and total indicator variances.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findIndResidualVar(lambda, totalFactorCov, totalVarTheta = NULL, 
	kappa = NULL, covcov = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lambda}] 
Factor loading matrix

\item[\code{totalFactorCov}] 
Total (model-implied) covariance matrix among factors. 

\item[\code{totalVarTheta}] 
Indicator total variances. As a default, all total variances are 1.

\item[\code{kappa}] 
Regression coefficient matrix from covariates (column) to indicators (rows)

\item[\code{covcov}] 
A covariance matrix among covariates

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of indicator residual variances.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndTotalVar}{findIndTotalVar}} to find indicator (measurement) total variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- c(0.6, 0.7, 0.8)
loading[4:6, 2] <- c(0.6, 0.7, 0.8)
facCov <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
totalVar <- rep(1, 6)
findIndResidualVar(loading, facCov, totalVar)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findIndTotalVar}{Find indicator total variances from factor loading matrix, total factor covariance, and indicator residual variances.}{findIndTotalVar}
%
\begin{Description}\relax
Find indicator total variances from a factor loading matrix, total factor covariance matrix, and indicator (measurement) residual variances.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findIndTotalVar(lambda, totalFactorCov, residualVarTheta, kappa = NULL, 
	covcov = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lambda}] 
Factor loading matrix

\item[\code{totalFactorCov}] 
Total (model-implied) covariance matrix among factors. 

\item[\code{residualVarTheta}] 
Indicator (measurement) residual variances. 

\item[\code{kappa}] 
Regression coefficient matrix from covariates (column) to indicators (rows)

\item[\code{covcov}] 
A covariance matrix among covariates

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A vector of indicator total variances.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findIndIntercept}{findIndIntercept}} to find indicator (measurement) intercepts
\item \code{\LinkA{findIndMean}{findIndMean}} to find indicator (measurement) total means
\item \code{\LinkA{findIndResidualVar}{findIndResidualVar}} to find indicator (measurement) residual variances
\item \code{\LinkA{findFactorIntercept}{findFactorIntercept}} to find factor intercepts
\item \code{\LinkA{findFactorMean}{findFactorMean}} to find factor means
\item \code{\LinkA{findFactorResidualVar}{findFactorResidualVar}} to find factor residual variances
\item \code{\LinkA{findFactorTotalVar}{findFactorTotalVar}} to find factor total variances
\item \code{\LinkA{findFactorTotalCov}{findFactorTotalCov}} to find factor covariances

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- c(0.6, 0.7, 0.8)
loading[4:6, 2] <- c(0.6, 0.7, 0.8)
facCov <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
resVar <- c(0.64, 0.51, 0.36, 0.64, 0.51, 0.36)
findIndTotalVar(loading, facCov, resVar)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findPossibleFactorCor}{Find the appropriate position for freely estimated correlation (or covariance) given a regression coefficient matrix}{findPossibleFactorCor}
%
\begin{Description}\relax
Find the appropriate position for freely estimated correlation (or covariance) given a regression coefficient matrix. The appropriate position is the pair of variables that are not causally related.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findPossibleFactorCor(beta)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
The regression coefficient in path analysis.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The symmetric matrix containing the appropriate position for freely estimated correlation.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findRecursiveSet}{findRecursiveSet}} to group variables regarding the position in mediation chain.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- NA
path[5, 2] <- path[8, 5] <- NA
path[6, 3] <- path[9, 6] <- NA
path[5, 1] <- path[8, 4] <- NA
path[6, 2] <- path[9, 5] <- NA
findPossibleFactorCor(path)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findPower}{Find a value of independent variables that provides a given value of power. }{findPower}
%
\begin{Description}\relax
Find a value of independent variable that provides a given value of power. If there are more than one varying parameters, this function will find the value of the target varying parameters given the values of the other varying parameters.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findPower(powerTable, iv, power)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{powerTable}] 
A \code{data.frame} providing varying parameters and powers of each parameter. This table is obtained by \code{\LinkA{getPower}{getPower}} or \code{\LinkA{continuousPower}{continuousPower}} function.

\item[\code{iv}] 
The target varying parameter that users would like to find the value providing a given power from. This argument can be specified as the index of the target column or the name of target column (i.e., \code{"iv.N"} or \code{"N"})

\item[\code{power}] 
A desired power.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
There are five possible types of values provided:
\begin{itemize}

\item \emph{Value} The varying parameter value that provides the power just over the specified power value (the adjacent value of varying parameter provides lower power than the specified power value).
\item \emph{Minimum value} The minimum value has already provided enough power (way over the specified power value). The value of varying parameters that provides exact desired power may be lower than the minimum value. The example of varying parameter that can provides the minimum value is sample size.
\item \emph{Maximum value} The maximum value has already provided enough power (way over the specified power value). The value of varying parameters that provides exact desired power may be higher than the maximum value. The example of varying parameter that can provides the maximum value is percent missing.
\item \code{NA} There is no value in the domain of varying parameters that provides the power greater than the desired power.
\item \code{Inf} The power of all values in the varying parameters is 1 (specifically more than 0.9999) and any values of the varying parameters can be picked and still provide enough power.

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{getPower}{getPower}} to find the power of parameter estimates		
\item \code{\LinkA{continuousPower}{continuousPower}} to find the power of parameter estimates for the result object (\code{linkS4class\{SimResult\}}) with varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Specify Sample Size by n
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.4)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))

# Find the power of all possible combination of N and pmMCAR
pow <- getPower(Output)

# Find the sample size that provides the power of 0.8
findPower(pow, "N", 0.80)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findRecursiveSet}{Group variables regarding the position in mediation chain}{findRecursiveSet}
%
\begin{Description}\relax
In mediation analysis, variables affects other variables as a chain. This function will group variables regarding the chain of mediation analysis.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findRecursiveSet(beta)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{beta}] 
The regression coefficient in path analysis.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The list of set of variables in the mediation chain. The variables in position 1 will be the independent variables. The variables in the last variables will be the end of the chain.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{findPossibleFactorCor}{findPossibleFactorCor}} to find the possible position for latent correlation given a regression coefficient matrix

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
path <- matrix(0, 9, 9)
path[4, 1] <- path[7, 4] <- NA
path[5, 2] <- path[8, 5] <- NA
path[6, 3] <- path[9, 6] <- NA
path[5, 1] <- path[8, 4] <- NA
path[6, 2] <- path[9, 5] <- NA
findRecursiveSet(path)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{generate}{Generate data using SimSem template}{generate}
%
\begin{Description}\relax
This function can be used to generate random data based on the 1. \code{\LinkA{SimSem}{SimSem.Rdash.class}} objects created with the \code{\LinkA{model}{model}} function, 2. \code{lavaan} script or parameter tables, or 3. an \code{MxModel} object from the \code{OpenMx} package. Some notable features include fine control of misspecification and misspecification optimization (for \code{\LinkA{SimSem}{SimSem.Rdash.class}} only), as well as the ability to generate non-normal data. When using \emph{simsem} for simulations, this function is used internally to generate data in the function \code{sim}, and can be helpful for debugging, or in creating data for use with other analysis programs. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
generate(model, n, maxDraw=50, misfitBounds=NULL, misfitType="f0",
	averageNumMisspec=FALSE, optMisfit=NULL, optDraws=50, 
	createOrder = c(1, 2, 3), indDist=NULL, sequential=FALSE,	
	facDist=NULL, errorDist=NULL, saveLatentVar = FALSE, indLab=NULL, 
	modelBoot=FALSE, realData=NULL, covData=NULL, params=FALSE, group = NULL, 
	empirical = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model}] 
A \code{\LinkA{SimSem}{SimSem.Rdash.class}} object, a \code{lavaan} script or parameter tables, or an \code{MxModel} object from the \code{OpenMx} package

\item[\code{n}] 
Integer of sample size.

\item[\code{maxDraw}] 
Integer specifying the maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).

\item[\code{misfitBounds}]  
Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.

\item[\code{misfitType}]  
Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be "f0", "rmsea", "srmr", or "all". 

\item[\code{averageNumMisspec}]  
If \code{TRUE}, the provided fit will be divided by the number of misspecified parameters. 

\item[\code{optMisfit}]  
Character vector of either "min" or "max" indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in "optDraws" that has either the maximum or minimum misfit of the given misfit type will be returned.

\item[\code{optDraws}]  
Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.

\item[\code{createOrder}] 
The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, \code{c(1, 2, 3)} is to apply constraints first, then add the misspecification, and finally fill all parameters. See the example of how to use it in the \code{\LinkA{draw}{draw}} function. 

\item[\code{indDist}]  
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for a distribution of indicators. If one object is passed, each indicator will have the same distribution. Use when \code{sequential} is \code{FALSE}.

\item[\code{sequential}]  
If \code{TRUE}, use a sequential method to create data such that the data from factor are generated first and apply to a set of equations to obtain the data of indicators. If \code{FALSE}, create data directly from model-implied mean and covariance of indicators.

\item[\code{facDist}]  
A \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object or list of objects for the distribution of factors. If one object is passed, all factors will have the same distribution. Use when \code{sequential} is \code{TRUE}.

\item[\code{errorDist}]  
An object or list of objects of type \code{SimDataDist} indicating the distribution of errors. If a single \code{SimDataDist} is specified, each error will be genrated with that distribution.

\item[\code{saveLatentVar}]  
If \code{TRUE}, the generated latent variable scores and measurement error scores are also provided as the \code{"latentVar"} attribute of the generated data by the following line: \code{attr(generatedData, "latentVar")}. The \code{sequential} argument must be \code{TRUE} in order to use this option.

\item[\code{indLab}]  
A vector of indicator labels. When not specified, the variable names are \code{x1, x2, ... xN}.

\item[\code{modelBoot}]  
When specified, a model-based bootstrap is used for data generation. See details for further information. This argument requires real data to be passed to \code{realData}.

\item[\code{realData}]  
A data.frame containing real data. The data generated will follow the distribution of this data set.

\item[\code{covData}]  
A data.frame containing covariate data, which can have any distributions. This argument is required when users specify \code{GA} or \code{KA} matrices in the model template (\code{\LinkA{SimSem}{SimSem.Rdash.class}}).

\item[\code{params}]  
If \code{TRUE}, return the parameters drawn along with the generated data set. Default is \code{FALSE}.

\item[\code{group}]  
The label of the grouping variable

\item[\code{empirical}]  
Logical. If \code{TRUE}, the specified parameters are treated as sample statistics and data are created to get the specified sample statistics. This argument is applicable when multivariate normal distribution is specified only.

\item[\code{...}]  
Additional arguments for the \code{\LinkA{simulateData}{simulateData}} function. 

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If the \code{lavaan} script or the \code{MxModel} are provided, the model-implied covariance matrix will be computed and internally use \code{\LinkA{createData}{createData}} function to generate data. The data-generation method is based on whether the \code{indDist} argument is specified. For the \code{lavaan} script, the code for data generation is modified from the \code{\LinkA{simulateData}{simulateData}} function.

If the \code{\LinkA{SimSem}{SimSem.Rdash.class}} object is specified, it will check whether there are any random parameters or trivial misspecification in the model. If so, real or misspecified parameters are drawn via the \code{\LinkA{draw}{draw}} function. Next, there are two methods to generate data. First, the function will calculate the model-implied covariance matrix (including model misspecification) and generate data similar to the \code{lavaan} script or the \code{MxModel} object. The second method is referred to as the \code{sequential} method, which can be used by specifying the \code{sequential} argument as \code{TRUE}. This function will create data based on the chain of equations in structural equation modeling such that independent variables and errors are generated and added as dependent variables and the dependent variables will be treated as independent variables in the next equation. For example, in the model with factor A and B are independent variables, factor C are dependent variables, factors A and B are generated first. Then, residual in factor C are created and added with factors A and B. This current step has all factor scores. Then, measurement errors are created and added with factor scores to create indicator scores. During each step, independent variables and errors can be nonnormal by setting \code{facDist} or \code{errorDist} arguments. The data generation in each step is based on the \code{\LinkA{createData}{createData}} function.

For the model-based bootstrap (providing the \code{realData} argument), the transformation proposed by Yung \& Bentler (1996) is used. This procedure is the expansion from the Bollen and Stine (1992) bootstrap including a mean structure. The model-implied mean vector and covariance matrix with trivial misspecification will be used in the model-based bootstrap if \code{misspec} is specified. See page 133 of Bollen and Stine (1992) for a reference. 
\end{Details}
%
\begin{Value}
A data.frame containing simulated data from the data generation template. A variable "group" is appended indicating group membership.
\end{Value}
%
\begin{Author}\relax
	
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}), the data generation code for lavaan script is modifed from the \code{simulateData} function in \code{lavaan} written by Yves Rosseel
\end{Author}
%
\begin{References}\relax
Bollen, K. A., \& Stine, R. A. (1992). Bootstrapping goodness-of-fit measures in structural equation models. \emph{Sociological Methods and Research, 21,} 205-229.

Yung, Y.-F., \& Bentler, P. M. (1996). Bootstrapping techniques in analysis of mean and covariance structures. In G. A. Marcoulides \& R. E. Schumacker (Eds.), \emph{Advanced structural equation modeling: Issues and techniques} (pp. 195-226). Mahwah, NJ: Erlbaum.
\end{References}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{draw}{draw}} To draw parameters using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{createData}{createData}} To generate random data using a set of parameters from \code{\LinkA{draw}{draw}}

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

dat <- generate(CFA.Model, 200)

# Get the latent variable scores

dat2 <- generate(CFA.Model, 20, sequential = TRUE, saveLatentVar = TRUE)
dat2
attr(dat2, "latentVar")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getCIwidth}{Find confidence interval width}{getCIwidth}
%
\begin{Description}\relax
Find the median of confidence interval width or a confidence interval value given a degree of assurance (Lai \& Kelley, 2011)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCIwidth(object, assurance = 0.50, nVal = NULL, pmMCARval = NULL, 
	pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results from multiple replications

\item[\code{assurance}] 
The percentile of the resulting confidence interval width. When assurance is 0.50, the median of the widths is provided. See Lai \& Kelley (2011) for more details.

\item[\code{nVal}] 
The sample size value that researchers wish to find the confidence interval width from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the confidence interval width from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the confidence interval width from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{df}] 
The degree of freedom used in spline method in predicting the confidence interval width by the predictors. If \code{df} is 0, the spline method will not be applied. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The median of confidence interval width or a confidence interval given a degree of assurance
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Lai, K., \& Kelley, K. (2011). Accuracy in parameter estimation for targeted effects in structural equation modeling: Sample size planning for narrow confidence intervals. \emph{Psychological Methods, 16}, 127-148.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for a detail of simResult
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- 1
RTE <- binds(error.cor)
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n = 200, model=CFA.Model)

# Get the cutoff (critical value) when alpha is 0.05
getCIwidth(Output, assurance=0.80)

# Finding the cutoff when the sample size is varied. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 <- sim(NULL, model=CFA.Model, n=seq(50, 100, 10))

# Get the fit index cutoff when sample size is 75.
getCIwidth(Output2, assurance=0.80, nVal = 75)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getCoverage}{Find coverage rate of model parameters }{getCoverage}
%
\begin{Description}\relax
A function to find the coverage rate of confidence intervals in a model when none, one, or more of the simulations parameters vary randomly across replications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCoverage(simResult, coverValue = NULL, contParam = NULL, coverParam = NULL, 
    nVal = NULL, pmMCARval = NULL, pmMARval = NULL, paramVal = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{simResult}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that may include randomly varying parameters (e.g. sample size, percent missing, model parameters)

\item[\code{coverValue}] 
A target value used that users wish to find the coverage rate of that value (e.g., 0). If \code{NULL}, the parameter values will be used.

\item[\code{contParam}] 
Vector of parameters names that vary over replications.

\item[\code{coverParam}] 
Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2"). If parameters are not specified, coverage rates for all parameters in the model will be returned.

\item[\code{nVal}] 
The sample size values that users wish to find power from.

\item[\code{pmMCARval}] 
The percent completely missing at random values that users wish to find power from.

\item[\code{pmMARval}] 
The percent missing at random values that users wish to find power from.

\item[\code{paramVal}] 
A list of varying parameter values that users wish to find power from.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In this function, the coverage (which can be 0 or 1) is regressed on randomly varying simulation parameters (e.g., sample size, percentage of missing data, or model parameters) using logistic regression. For a set of independent variables values, the predicted probability from the logistic regression equation is the predicted coverage rate.
\end{Details}
%
\begin{Value}
Data frame containing columns representing values of the randomly varying simulation parameters, and coverage rates for model parameters of interest.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Get the coverage rates of all possible combinations of n and pmMCAR
getCoverage(Output)

# Get the coverage rates of the combinations of n of 100 and 200 and pmMCAR of 0, 0.1, and 0.2
getCoverage(Output, coverValue = 0, nVal=c(100, 200), pmMCARval=c(0, 0.1, 0.2))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getCutoff}{Find fit indices cutoff given a priori alpha level}{getCutoff}
%
\begin{Description}\relax
Extract fit indices information from the \code{\LinkA{SimResult}{SimResult.Rdash.class}} and get the cutoffs of fit indices given a priori alpha level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCutoff(object, alpha, revDirec = FALSE, usedFit = NULL, nVal = NULL, 
	pmMCARval = NULL, pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results from multiple replications

\item[\code{alpha}] 
A priori alpha level

\item[\code{revDirec}] 
The default is to find criticl point on the side that indicates worse fit (the right side of RMSEA or the left side of CFI). If specifying as \code{TRUE}, the directions are reversed.

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.

\item[\code{nVal}] 
The sample size value that researchers wish to find the fit indices cutoffs from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the fit indices cutoffs from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the fit indices cutoffs from. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied. This argument is applicable for \code{\LinkA{SimResult}{SimResult.Rdash.class}} with varying sample sizes or percent missing across replications

\end{ldescription}
\end{Arguments}
%
\begin{Value}
One-tailed cutoffs of several fit indices with a priori alpha level 
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for a detail of simResult
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- 1
RTE <- binds(error.cor)
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n = 200, model=CFA.Model)

# Get the cutoff (critical value) when alpha is 0.05
getCutoff(Output, 0.05)

# Finding the cutoff when the sample size is varied. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 <- sim(NULL, model=CFA.Model, n=seq(50, 100, 10))

# Get the fit index cutoff when sample size is 75.
getCutoff(Output2, 0.05, nVal = 75)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getCutoffNested}{Find fit indices cutoff for nested model comparison given a priori alpha level}{getCutoffNested}
%
\begin{Description}\relax
Extract fit indices information from the simulation of parent and nested models and getCutoff of fit indices given a priori alpha level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCutoffNested(nested, parent, alpha = 0.05, usedFit = NULL, nVal = NULL, 
	pmMCARval = NULL, pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of nested model from multiple replications

\item[\code{parent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of parent model from multiple replications

\item[\code{alpha}] 
A priori alpha level

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.

\item[\code{nVal}] 
The sample size value that researchers wish to find the fit indices cutoffs from.

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
One-tailed cutoffs of several fit indices with a priori alpha level 
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for a detail of simResult
\code{\LinkA{getCutoff}{getCutoff}} for a detail of finding cutoffs for absolute fit
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Nested Model
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))

error.cor.mis <- matrix("rnorm(1, 0, 0.1)", 6, 6)
diag(error.cor.mis) <- 1
RTE <- binds(diag(6), misspec=error.cor.mis)
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Parent Model
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.NULL.NULL <- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.NULL.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL)

# Find the fix index cutoff from the sampling distribution of the difference
# in fit index of nested models where the alpha is 0.05.
getCutoffNested(Output.NULL.NULL, Output.NULL.ALT, alpha=0.05)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getCutoffNonNested}{Find fit indices cutoff for non-nested model comparison given a priori alpha level}{getCutoffNonNested}
%
\begin{Description}\relax
Extract fit indices information from the simulation of two models fitting on the datasets created from both models and getCutoff of fit indices given a priori alpha level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getCutoffNonNested(dat1Mod1, dat1Mod2, dat2Mod1=NULL, dat2Mod2=NULL, 
alpha=.05, usedFit=NULL, onetailed=FALSE, nVal = NULL, pmMCARval = NULL, 
pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dat1Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1

\item[\code{dat1Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1

\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{alpha}] 
A priori alpha level

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to get cutoffs from. The default is to get cutoffs of all fit indices.

\item[\code{onetailed}] 
If \code{TRUE}, the function will find the cutoff from one-tail test. If \code{FALSE}, the funciton will find the cutoff from two-tailed test.

\item[\code{nVal}] 
The sample size value that researchers wish to find the fit indices cutoffs from.

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
One- or two-tailed cutoffs of several fit indices with a priori alpha level. The cutoff is based on the fit indices from Model 1 subtracted by the fit indices from Model 2.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for a detail of simResult
\code{\LinkA{getCutoff}{getCutoff}} for a detail of finding cutoffs for absolute fit
\code{\LinkA{getCutoffNested}{getCutoffNested}} for a detail of finding cutoffs for nested model comparison
\code{\LinkA{plotCutoffNonNested}{plotCutoffNonNested}} Plot cutoffs for non-nested model comparison
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A: Factor 1 with items 1-3 and Factor 2 with items 4-8
loading.A <- matrix(0, 8, 2)
loading.A[1:3, 1] <- NA
loading.A[4:8, 2] <- NA
LY.A <- bind(loading.A, 0.7)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE <- binds(diag(8))
CFA.Model.A <- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 with items 1-4 and Factor 2 with items 5-8
loading.B <- matrix(0, 8, 2)
loading.B[1:4, 1] <- NA
loading.B[5:8, 2] <- NA
LY.B <- bind(loading.B, 0.7)
CFA.Model.B <- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Find the cutoffs from the sampling distribution to reject model A (model 1)
# and to reject model B (model 2)
getCutoffNonNested(Output.A.A, Output.A.B, Output.B.A, Output.B.B)

# Find the cutoffs from the sampling distribution to reject model A (model 1)
getCutoffNonNested(Output.A.A, Output.A.B)

# Find the cutoffs from the sampling distribution to reject model B (model 1)
getCutoffNonNested(Output.B.B, Output.B.A)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getExtraOutput}{Get extra outputs from the result of simulation}{getExtraOutput}
%
\begin{Description}\relax
Get extra outputs from a simulation result object (\code{\LinkA{SimResult}{SimResult.Rdash.class}}). Users can ask this package to extra output from the \code{\LinkA{lavaan}{lavaan.Rdash.class}} object in each iteration by setting the \code{outfun} argument (in the \code{sim} function). See the example below.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getExtraOutput(object, improper = FALSE, nonconverged = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that have the extra output extracted by the function defined in the \code{outfun} argument (in the \code{sim} function)

\item[\code{improper}] 
Specify whether to include the information from the replications with improper solutions

\item[\code{nonconverged}] 
Specify whether to include the information from the nonconvergent replications

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of extra outputs
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{sim}{sim}} A function to run a Monte Carlo simulation

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Write a function to extract the modification index from lavaan object
outfun <- function(out) {
	result <- inspect(out, "mi")
}

# We will use only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=200, model=CFA.Model, outfun=outfun)

# Get the modification index of each replication
getExtraOutput(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPopulation}{Extract the data generation population model underlying a result object}{getPopulation}
%
\begin{Description}\relax
This function will extract the data generation population model underlying a result object (\code{linkS4class\{SimResult\}}).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPopulation(object, improper = FALSE, nonconverged = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The result object that you wish to extract the data generation population model from (\code{linkS4class\{SimResult\}}).

\item[\code{improper}] 
Specify whether to include the information from the replications with improper solutions

\item[\code{nonconverged}] 
Specify whether to include the information from the nonconvergent replications

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame contained the population of each replication
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for result object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, "runif(1, 0.4, 0.9)")
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We will use only 10 replications to save time.
# In reality, more replications are needed.
Output <- sim(10, n=200, model=CFA.Model)

# Get the population parameters
getPopulation(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPower}{Find power of model parameters }{getPower}
%
\begin{Description}\relax
A function to find the power of  parameters in a model when none, one, or more of the simulations parameters vary randomly across replications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPower(simResult, alpha = 0.05, contParam = NULL, powerParam = NULL, 
	nVal = NULL, pmMCARval = NULL, pmMARval = NULL, paramVal = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{simResult}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that may include randomly varying parameters (e.g. sample size, percent missing, model parameters)

\item[\code{alpha}] 
Alpha level to use for power analysis.

\item[\code{contParam}] 
Vector of parameters names that vary over replications.

\item[\code{powerParam}] 
Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2"). If parameters are not specified, power for all parameters in the model will be returned.

\item[\code{nVal}] 
The sample size values that users wish to find power from.

\item[\code{pmMCARval}] 
The percent completely missing at random values that users wish to find power from.

\item[\code{pmMARval}] 
The percent missing at random values that users wish to find power from.

\item[\code{paramVal}] 
A list of varying parameter values that users wish to find power from.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A common use of simulations is to conduct power analyses, especially when using SEM (Muthen \& Muthen, 2002). Here, researchers could select values for each parameter and a sample size and run a simulation to determine power in those conditions (the proportion of generated datasets in which a particular parameter of interest is significantly different from zero). To evaluate power at multiple sample sizes, one simulation for each sample size must be run. This function not only calculate power for each sample size but also calculate power for multiple sample sizes varying continuously. By continuously varying sample size across replications, only a single simulation is needed. In this simulation, the sample size for each replication varies randomly across plausible sample sizes (e.g., sample sizes between 200 and 500). For each replication, the sample size and significance of each parameter (0 = not significant, 1 = significant) are recorded. When the simulation is complete, parameter significance is regressed on sample size using logistic regression. For a given sample size, the predicted probability from the logistic regression equation is the power to detect an effect at that sample size. This approach can be extended to other randomly varying simulation parameters such as the percentage of missing data, and model parameters.
\end{Details}
%
\begin{Value}
Data frame containing columns representing values of the randomly varying simulation parameters, and power for model parameters of interest.
\end{Value}
%
\begin{Author}\relax
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu}), Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Muthen, L. K., \& Muthen, B. O. (2002). How to use a Monte Carlo study to decide on sample size and determine power. \emph{Structural Equation Modeling, 4,} 599-620.
\end{References}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both sample size and percent missing completely at random. Note that more fine-grained 
# values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) and pmMCAR=seq(0, 0.2, 0.01)
Output <- sim(NULL, model=CFA.Model, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2))
summary(Output)

# Get the power of all possible combinations of n and pmMCAR
getPower(Output)

# Get the power of the combinations of n of 100 and 200 and pmMCAR of 0, 0.1, and 0.2
getPower(Output, nVal=c(100, 200), pmMCARval=c(0, 0.1, 0.2))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPowerFit}{Find power in rejecting alternative models based on fit indices criteria}{getPowerFit}
%
\begin{Description}\relax
Find the proportion of fit indices that indicate worse fit than a specified cutoffs. The cutoffs may be calculated from \code{\LinkA{getCutoff}{getCutoff}} of the null model.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPowerFit(altObject, cutoff = NULL, nullObject = NULL, revDirec = FALSE, 
usedFit = NULL, alpha = 0.05, nVal = NULL, pmMCARval = NULL, pmMARval = NULL, 
condCutoff = TRUE, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{altObject}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that indicates alternative model that users wish to reject

\item[\code{cutoff}] 
Fit indices cutoffs from null model or users. This should be a vector with a specified fit indices names as the name of vector elements. The \code{cutoff} cannot be specified if the \code{nullObject} is specified.

\item[\code{nullObject}] 
The \code{\LinkA{SimResult}{SimResult.Rdash.class}} that contains the simulation result from fitting the null model by the data from the null model. The \code{nullObject} cannot be specified if the \code{cutoff} is specified.

\item[\code{revDirec}] 
Reverse the direction of deciding a power by fit indices (e.g., less than --> greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as \code{TRUE}.

\item[\code{usedFit}] 
The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices

\item[\code{alpha}] 
The alpha level used to find the cutoff if the \code{nullObject} is specified. This argument is not applicable if the \code{cutoff} is specified.

\item[\code{nVal}] 
The sample size value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random sample size. 

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing completely at random. 

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing at random. 

\item[\code{condCutoff}] 
A logical value to use a conditional quantile method (if \code{TRUE}) or logistic regression method (if \code{FALSE}) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies \code{nVal}, \code{pmMCARval}, or \code{pmMARval}. The value of 1 - quantile will be reported as the power given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The predicted probability is reported as a power. This argument is applicable for specification of \code{cutoff} only.

\item[\code{df}] 
The degree of freedom used in spline method in quantile regression (\code{condCutoff = TRUE}). If \code{df} is 0, which is the default, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of power given different fit indices. The \code{TraditionalChi} means the proportion of replications that are rejected by the traditional chi-square test.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{getCutoff}{getCutoff}} to find the cutoffs from null model.
\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create simResult

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Null model with one factor
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.NULL <- sim(5, n=500, model=CFA.Model.NULL)

# Get the fit index cutoff from the null model
Cut.NULL <- getCutoff(Output.NULL, 0.05)

# Alternative model with two factor
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.ALT <- sim(5, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Get the power based on the derived cutoff
getPowerFit(Output.ALT, cutoff=Cut.NULL)

# Get the power based on the rule of thumb proposed by Hu & Bentler (1999)
Rule.of.thumb <- c(RMSEA=0.05, CFI=0.95, TLI=0.95, SRMR=0.06)
getPowerFit(Output.ALT, cutoff=Rule.of.thumb, usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.ALT2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Get the power based on the derived cutoff from the null model at the sample size of 250
getPowerFit(Output.ALT2, nullObject=Output.NULL2, nVal=250)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPowerFitNested}{Find power in rejecting nested models based on the differences in fit indices }{getPowerFitNested}
%
\begin{Description}\relax
Find the proportion of the difference in fit indices that indicate worse fit than a specified (or internally derived) cutoffs. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPowerFitNested(altNested, altParent, cutoff = NULL, nullNested = NULL, 
nullParent = NULL, revDirec = FALSE, usedFit = NULL, alpha = 0.05, nVal = NULL, 
pmMCARval = NULL, pmMARval = NULL, condCutoff = TRUE, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{altNested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the nested model when the nested model is \code{FALSE}.

\item[\code{altParent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the parent model when the nested model is \code{FALSE}.

\item[\code{cutoff}] 
A vector of priori cutoffs for fit indices. The \code{cutoff} cannot be specified if the \code{nullNested} and \code{nullParent} are specified.

\item[\code{nullNested}] 
The \code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the nested model when the nested model is \code{TRUE}. This argument must be specified with \code{nullParent}. The \code{nullNested} cannot be specified if the \code{cutoff} is specified.

\item[\code{nullParent}] 
The \code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the parent model when the nested model is \code{TRUE}. This argument must be specified with \code{nullNested}. The \code{nullNested} cannot be specified if the \code{cutoff} is specified.

\item[\code{revDirec}] 
Reverse the direction of deciding a power by fit indices (e.g., less than --> greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as \code{TRUE}.

\item[\code{usedFit}] 
The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices

\item[\code{alpha}] 
The alpha level used to find the cutoff if the \code{nullObject} is specified. This argument is not applicable if the \code{cutoff} is specified.

\item[\code{nVal}] 
The sample size value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random sample size. 

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing completely at random. 

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing at random. 

\item[\code{condCutoff}] 
A logical value to use a conditional quantile method (if \code{TRUE}) or logistic regression method (if \code{FALSE}) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies \code{nVal}, \code{pmMCARval}, or \code{pmMARval}. The value of 1 - quantile will be reported as the power given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The predicted probability is reported as a power. This argument is applicable for specification of \code{cutoff} only.

\item[\code{df}] 
The degree of freedom used in spline method in quantile regression (\code{condCutoff = TRUE}). If \code{df} is 0, which is the default, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of power given different fit indices. The \code{TraditionalChi} means the proportion of replications that are rejected by the traditional chi-square difference test.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{getCutoff}{getCutoff}} to find the cutoffs from null model.
\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create simResult

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Null model (Nested model) with one factor
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Alternative model (Parent model) with two factors
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, 0.7)
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# We make the examples running only 10 replications to save time.
# In reality, more replications are needed.
Output.NULL.NULL <- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL <- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Find the power based on the derived cutoff from the models analyzed on the null datasets
getPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT)

# Find the power based on the chi-square value at df=1 and the CFI change (intentionally
# use a cutoff from Cheung and Rensvold (2002) in an appropriate situation).
getPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, cutoff=c(Chi=3.84, CFI=-0.10))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL.NULL2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT2 <- sim(NULL, n=seq(50, 500, 50), model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Get the power based on the derived cutoff from the null model at the sample size of 250
getPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2, nVal = 250)

# Get the power based on the rule of thumb from the null model at the sample size of 250
getPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, cutoff=c(Chi=3.84, CFI=-0.10), nVal = 250)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getPowerFitNonNested}{Find power in rejecting non-nested models based on the differences in fit indices }{getPowerFitNonNested}
\aliasA{getPowerFitNonNested,SimResult,SimResult,missing-method}{getPowerFitNonNested}{getPowerFitNonNested,SimResult,SimResult,missing.Rdash.method}
\aliasA{getPowerFitNonNested,SimResult,SimResult,vector-method}{getPowerFitNonNested}{getPowerFitNonNested,SimResult,SimResult,vector.Rdash.method}
\aliasA{getPowerFitNonNested-methods}{getPowerFitNonNested}{getPowerFitNonNested.Rdash.methods}
%
\begin{Description}\relax
Find the proportion of the difference in fit indices from one model that does not in the range of sampling distribution from another model (reject that the dataset comes from the second model) or indicates worse fit than a specified cutoff. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPowerFitNonNested(dat2Mod1, dat2Mod2, cutoff = NULL, dat1Mod1 = NULL, 
dat1Mod2 = NULL, revDirec = FALSE, usedFit = NULL, alpha = 0.05, nVal = NULL, 
pmMCARval = NULL, pmMARval = NULL, condCutoff = TRUE, df = 0, onetailed = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{cutoff}] 
A vector of priori cutoffs for fit indices. The \code{cutoff} cannot be specified if the \code{dat1Mod1} and \code{dat1Mod2} are specified.

\item[\code{dat1Mod1}] 
The \code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1. This argument must be specified with \code{dat1Mod2}. The \code{dat1Mod1} cannot be specified if the \code{cutoff} is specified.

\item[\code{dat1Mod2}] 
The \code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1. This argument must be specified with \code{dat1Mod1}. The \code{dat1Mod2} cannot be specified if the \code{cutoff} is specified.

\item[\code{revDirec}] 
Reverse the direction of deciding a power by fit indices (e.g., less than --> greater than). The default is to count the proportion of fit indices that indicates lower fit to the model, such as how many RMSEA in the alternative model that is worse than cutoffs. The direction can be reversed by setting as \code{TRUE}.

\item[\code{usedFit}] 
The vector of names of fit indices that researchers wish to get powers from. The default is to get powers of all fit indices

\item[\code{alpha}] 
The alpha level used to find the cutoff if the \code{nullObject} is specified. This argument is not applicable if the \code{cutoff} is specified.

\item[\code{nVal}] 
The sample size value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random sample size. 

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing completely at random. 

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the power from. This argument is applicable when \code{altObject} has a random percent missing at random. 

\item[\code{condCutoff}] 
A logical value to use a conditional quantile method (if \code{TRUE}) or logistic regression method (if \code{FALSE}) to find the power. The conditional quantile method use quantile regression to find the quantile of the cutoff on the alternative sampling distribution that varies \code{nVal}, \code{pmMCARval}, or \code{pmMARval}. The value of 1 - quantile will be reported as the power given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The logistic regression method is based on transforming the fit indices value to reject/retain decision first. Then, the logistic regression is used to predict reject/retain decision given the set of \code{nVal}, \code{pmMCARval}, and \code{pmMARval}. The predicted probability is reported as a power. This argument is applicable for specification of \code{cutoff} only.

\item[\code{df}] 
The degree of freedom used in spline method in quantile regression (\code{condCutoff = TRUE}). If \code{df} is 0, which is the default, the spline method will not be applied.

\item[\code{onetailed}] 
Derive the cutoff by using one-tailed test if specified as \code{TRUE}. This argument is applicable only when \code{dat1Mod1} and \code{dat1Mod2} are specified.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
List of power given different fit indices.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{getCutoffNonNested}{getCutoffNonNested}} to find the cutoffs for non-nested model comparison
\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create simResult

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A <- matrix(0, 8, 2)
loading.A[1:3, 1] <- NA
loading.A[4:8, 2] <- NA
LY.A <- bind(loading.A, 0.7)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE <- binds(diag(8))
CFA.Model.A <- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B <- matrix(0, 8, 2)
loading.B[1:4, 1] <- NA
loading.B[5:8, 2] <- NA
LY.B <- bind(loading.B, 0.7)
CFA.Model.B <- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A) 
Output.A.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A) 
Output.B.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B) 
Output.B.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B) 

# Find the power based on the derived cutoff for both models
getPowerFitNonNested(Output.B.A, Output.B.B, dat1Mod1=Output.A.A, dat1Mod2=Output.A.B)

# Find the power based on the AIC and BIC of 0 (select model B if Output.B.B has lower AIC or BIC)
getPowerFitNonNested(Output.B.A, Output.B.B, cutoff=c(AIC=0, BIC=0))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{imposeMissing}{  Impose MAR, MCAR, planned missingness, or attrition on a data set}{imposeMissing}
\aliasA{impose}{imposeMissing}{impose}
%
\begin{Description}\relax
Function imposes missing values on a data based on the known missing data types,
including MCAR, MAR, planned, and attrition.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
impose(miss, data.mat, pmMCAR = NULL, pmMAR = NULL)
imposeMissing(data.mat, cov = 0, pmMCAR = 0, pmMAR = 0, nforms = 0, 
	itemGroups = list(), twoMethod = 0, prAttr = 0, timePoints = 1, 
	ignoreCols = 0, threshold = 0, logit = "", logical = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{miss}] 
Missing data object (\code{\LinkA{SimMissing}{SimMissing.Rdash.class}}) used as the template for impose missing values

\item[\code{data.mat}] 
Data to impose missing upon. Can be either a matrix or a data frame. 

\item[\code{cov}] 
Column indices of a covariate to be used to impose MAR missing, or
MAR attrition. Will not be included in any removal procedure. See details.

\item[\code{pmMCAR}] 
Decimal percent of missingness to introduce completely at random on all variables.

\item[\code{pmMAR}] 
Decimal percent of missingness to introduce using the listed
covariate as predictor. See details.

\item[\code{nforms}] 
The number of forms for planned missing data designs, not including
the shared form.

\item[\code{itemGroups}] 
List of lists of item groupings for planned missing data
forms. Unless specified, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)

\item[\code{twoMethod}] 
With missing on one variable: vector of (column index, percent missing). Will put a given percent
missing on that column in the matrix to simulate a two method
planned missing data research design. With missing on two or more variables: list of (column indices, percent missing).

\item[\code{prAttr}] 
Probability (or vector of probabilities) of an entire case being removed due to attrition at a
given time point. When a covariate is specified along with this argument, attrition
will be predicted by the covariate (MAR attrition). See details.

\item[\code{timePoints}] 
Number of timepoints items were measured over. For longitudinal
data, planned missing designs will be implemented within each
timepoint. All methods to impose missing values over time assume an equal number of
variables at each time point.

\item[\code{ignoreCols}] 
The columns not imposed any missing values for any missing data patterns.

\item[\code{threshold}] 
The threshold of the covariate used to impose missing values. Values
on the covariate above this threshold are eligible to be
deleted. The default threshold is the mean of the variable.

\item[\code{logit}] 
The script used for imposing missing values by logistic regression. The script is similar to the specification of regression in \code{lavaan} such that each line begins with a dependent variable, then '\textasciitilde{}' is used as regression sign, and the formula of a linear combination of independent variable plus constant, such as y1 \textasciitilde{} 0.5 + 0.2*y2. '\#' and '!' can be used as a comment (like \code{lavaan}). For the intercept, users may use 'p()' to specify the average proportion of missing, such as y1 \textasciitilde{} p(0.2) + 0.3*y2, which the average missing proportion of y1 is 0.2 and the missing of y1 depends on y2. Users may visualize the missing proportion from the logistic specification by the \code{\LinkA{plotLogitMiss}{plotLogitMiss}} function.

\item[\code{logical}] 
A matrix of logical values (\code{TRUE/FALSE}). If a value in the dataset is corresponding to the \code{TRUE} in the logical matrix, the value will be missing.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Without specifying any arguments, no missing values will be
introduced.

A single covariate is required to specify MAR missing - this
covariate can be distributed in any way. This covariate can be either continuous or categorical, as long as it is
numerical. If the covariate is categorical, the threshold should be
specified to one of the levels.

MAR missingness is specified using the threshold method - any value on the covariate that is above
the specified threshold indicates a row eligible for deletion. If the
specified total amount of MAR missingness is not possible given the
total rows eligible based on the threshold, the function iteratively
lowers the threshold until the total percent missing is possible.

Planned missingness is parameterized by the number of forms (n). This is used to divide the
cases into n groups. If the column groupings are not specified, a naive
method will be used that divides the columns into n+1 equal forms
sequentially (1-4,5-9,10-13..), where the first group is the shared
form.The first list of column indices given will be used as the shared
group. If this is not desired, this list can be left empty.

For attrition, the probability can be specified as a single value or as
a vector. For a single value, the probability of attrition will be
the same across time points, and affects only
cases not previously lost due to attrition. If this argument is a
vector, this specifies different probabilities of
attrition for each time point. Values will be recycled if this
vector is smaller than the specified number of time points.

An MNAR processes can be generated by specifying MAR missingness and then
dropping the covariate from the subsequent analysis.

Currently, if MAR missing is imposed along with attrition, both processes will use
the same covariate and threshold.

Currently, all types of missingness (MCAR, MAR, planned, and attrition)
are imposed independently. This means that specified global values of
percent missing will not be additive (10 percent MCAR + 10 percent MAR
does not equal 20 percent total missing). 
\end{Details}
%
\begin{Value}
A data matrix with \code{NA}s introduced in the way specified by the arguments.
\end{Value}
%
\begin{Author}\relax
Patrick Miller(University of Kansas; \email{patr1ckm@ku.edu})
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})  

\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimMissing}{SimMissing.Rdash.class}} for the alternative way to save missing data feature for using in the \code{\LinkA{sim}{sim}} function.


\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
data <- matrix(rep(rnorm(10,1,1),19),ncol=19)
datac <- cbind(data,rnorm(10,0,1),rnorm(10,5,5))

# Imposing Missing with the following arguments produces no missing values
imposeMissing(data)
imposeMissing(data,cov=c(1,2))
imposeMissing(data,pmMCAR=0)
imposeMissing(data,pmMAR=0)
imposeMissing(data,nforms=0)

#Some more usage examples

# No missing at variables 1 and 2
imposeMissing(data,cov=c(1,2),pmMCAR=.1)

# 3-Form design
imposeMissing(data,nforms=3)

# 3-Form design with specified groups of items (XABC)
imposeMissing(data, nforms = 3, itemGroups =
	list(c(1,2,3,4,5), c(6,7,8,9,10), c(11,12,13,14,15), c(16,17,18,19)))

# 3-Form design when variables 20 and 21 are not missing
imposeMissing(datac,cov=c(20,21),nforms=3)

# 2 method design where the expensive measure is on Variable 19
imposeMissing(data,twoMethod=c(19,.8))

# Impose missing data with percent attrition of 0.1 in 5 time points
imposeMissing(datac,cov=21,prAttr=.1,timePoints=5)

# Logistic-regression MAR
colnames(data) <- paste("y", 1:ncol(data), sep="")
script <- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
		y4 ~ -2 + 0.1*y4
		y5 ~ -0.5'
imposeMissing(data, logit=script)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{inspect}{Extract information from a simulation result}{inspect}
\aliasA{inspect,SimResult-method}{inspect}{inspect,SimResult.Rdash.method}
%
\begin{Description}\relax
Extract information from a simulation result
\end{Description}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The target \code{\LinkA{SimResult}{SimResult.Rdash.class}} object

\item[\code{what}] 
The target component to be extracted. Please see details below.

\item[\code{improper}] 
Specify whether to include the information from the replications with improper solutions

\item[\code{nonconverged}] 
Specify whether to include the information from the nonconvergent replications

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Here are the list of information that can be specified in the \code{what} argument. The items starting with * are the information that the \code{improper} and \code{nonconverged} arguments are not applicable.
\begin{itemize}

\item *\code{"modeltype"}: The type of the simulation result
\item *\code{"nrep"}: The number of overall replications, including converged and nonconverged replications
\item \code{"param"}: Parameter values (equivalent to the \code{\LinkA{getPopulation}{getPopulation}} function)
\item \code{"coef"}: Parameter estimates (equivalent to the \code{\LinkA{coef}{coef,SimResult.Rdash.method}} method)
\item \code{"se"}: Standard errors
\item \code{"fit"}: Fit indices
\item \code{"misspec"}: Misspecified parameter values
\item \code{"popfit"}: Population misfit
\item \code{"fmi1"}: Fraction missings type 1
\item \code{"fmi2"}: Fraction missings type 2
\item \code{"cilower"}: Lower bounds of confidence intervals
\item \code{"ciupper"}: Upper bounds of confidence intervals
\item \code{"ciwidth"}: Widths of confidence intervals
\item *\code{"seed"}: Seed number (equivalent to the \code{\LinkA{summarySeed}{summarySeed}} function)
\item \code{"ngroup"}: Sample size of each group
\item \code{"ntotal"}: Total sample size
\item \code{"mcar"}: Percent missing completely at random
\item \code{"mar"}: Percent missing at random
\item \code{"extra"}: Extra output from the \code{outfun} argument from the \code{\LinkA{sim}{sim}} function)
\item *\code{"time"}: Time elapsed in running the simulation (equivalent to the \code{\LinkA{summaryTime}{summaryTime}} function) 
\item *\code{"converged"}: Convergence of each replication

\end{itemize}

\end{Details}
%
\begin{Value}
The target information depending on the \code{what} argument
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model, n=200)
inspect(Output, "coef")
inspect(Output, "param")
inspect(Output, "se", improper = TRUE, nonconverged = TRUE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{likRatioFit}{Find the likelihood ratio (or Bayes factor) based on the bivariate distribution of fit indices}{likRatioFit}
%
\begin{Description}\relax
Find the log-likelihood of the observed fit indices on Model 1 and 2 from the real data on the bivariate sampling distribution of fit indices fitting Model 1 and Model 2 by the datasets from the Model 1 and Model 2. Then, the likelihood ratio is computed (which may be interpreted as posterior odd). If the prior odd is 1 (by default), the likelihood ratio is equivalent to Bayes Factor.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
likRatioFit(outMod1, outMod2, dat1Mod1, dat1Mod2, dat2Mod1, dat2Mod2, 
usedFit=NULL, prior=1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{outMod1}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the first model from the target dataset

\item[\code{outMod2}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the second model from the target dataset

\item[\code{dat1Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1

\item[\code{dat1Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1

\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.

\item[\code{prior}] 
The prior odds. The prior probability that Model 1 is correct over the prior probability that Model 2 is correct.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The likelihood ratio (Bayes Factor) in preference of Model 1 to Model 2. If the value is greater than 1, Model 1 is preferred. If the value is less than 1, Model 2 is preferred.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for a detail of simResult
\code{\LinkA{pValueNested}{pValueNested}} for a nested model comparison by the difference in fit indices
\code{\LinkA{pValueNonNested}{pValueNonNested}} for a nonnested model comparison by the difference in fit indices
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A; Factor 1 --> Factor 2; Factor 2 --> Factor 3
library(lavaan)
loading <- matrix(0, 11, 3)
loading[1:3, 1] <- NA
loading[4:7, 2] <- NA
loading[8:11, 3] <- NA
path.A <- matrix(0, 3, 3)
path.A[2, 1] <- NA
path.A[3, 2] <- NA
model.A <- estmodel(LY=loading, BE=path.A, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.A <- analyze(model.A, PoliticalDemocracy)

# Model A; Factor 1 --> Factor 3; Factor 3 --> Factor 2
path.B <- matrix(0, 3, 3)
path.B[3, 1] <- NA
path.B[2, 3] <- NA
model.B <- estmodel(LY=loading, BE=path.B, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.B <- analyze(model.B, PoliticalDemocracy)

loading.mis <- matrix("runif(1, -0.2, 0.2)", 11, 3)
loading.mis[is.na(loading)] <- 0

# Create SimSem object for data generation and data analysis template
datamodel.A <- model.lavaan(out.A, std=TRUE, LY=loading.mis)
datamodel.B <- model.lavaan(out.B, std=TRUE, LY=loading.mis)

# Get sample size
n <- nrow(PoliticalDemocracy)

# The actual number of replications should be greater than 20.
output.A.A <- sim(20, n=n, model.A, generate=datamodel.A) 
output.A.B <- sim(20, n=n, model.B, generate=datamodel.A)
output.B.A <- sim(20, n=n, model.A, generate=datamodel.B)
output.B.B <- sim(20, n=n, model.B, generate=datamodel.B)

# Find the likelihood ratio ;The output may contain some warnings here. 
# When the number of replications increases (e.g., 1000), the warnings should disappear.
likRatioFit(out.A, out.B, output.A.A, output.A.B, output.B.A, output.B.B)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{miss}{  Specifying the missing template to impose on a dataset}{miss}
%
\begin{Description}\relax
Specifying the missing template (\code{\LinkA{SimMissing}{SimMissing.Rdash.class}}) to impose on a dataset. The template will be used in Monte Carlo simulation such that, in the \code{\LinkA{sim}{sim}} function, datasets are created and imposed by missing values created by this template. See \code{\LinkA{imposeMissing}{imposeMissing}} for further details of each argument.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
miss(cov = 0, pmMCAR = 0, pmMAR = 0, logit = "", nforms = 0, itemGroups = list(), 
    timePoints = 1, twoMethod = 0, prAttr = 0, m = 0, chi = "all", 
	package = "default", convergentCutoff = 0.8, ignoreCols = 0, 
    threshold = 0, covAsAux = TRUE, logical = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{cov}] Column indices of any normally distributed covariates used in the data set.
\item[\code{pmMCAR}] Decimal percent of missingness to introduce completely at random on all variables.
\item[\code{pmMAR}] Decimal percent of missingness to introduce using the listed covariates as predictors.
\item[\code{logit}] The script used for imposing missing values by logistic regression. The script is similar to the specification of regression in \code{lavaan} such that each line begins with a dependent variable, then '\textasciitilde{}' is used as regression sign, and the formula of a linear combination of independent variable plus constant, such as y1 \textasciitilde{} 0.5 + 0.2*y2. '\#' and '!' can be used as a comment (like \code{lavaan}). For the intercept, users may use 'p()' to specify the average proportion of missing, such as y1 \textasciitilde{} p(0.2) + 0.3*y2, which the average missing proportion of y1 is 0.2 and the missing of y1 depends on y2. Users may visualize the missing proportion from the logistic specification by the \code{\LinkA{plotLogitMiss}{plotLogitMiss}} function.
\item[\code{nforms}] The number of forms for planned missing data designs, not including the shared form.
\item[\code{itemGroups}] List of lists of item groupings for planned missing data forms. Without this, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)
\item[\code{timePoints}] Number of timepoints items were measured over. For longitudinal data, planned missing designs will be implemented within each timepoint.
\item[\code{twoMethod}] With missing on one variable: vector of (column index, percent missing). Will put a given percent missing on that column in the matrix to simulate a two method planned missing data research design. With missing on two or more variables: list of (column indices, percent missing). 
\item[\code{prAttr}] Probability (or vector of probabilities) of an entire case being removed due to attrition at a given time point. See \code{\LinkA{imposeMissing}{imposeMissing}} for further details.
\item[\code{m}] The number of imputations. The default is 0 such that the full information maximum likelihood is used.
\item[\code{chi}] The chi-square pooling method. See \code{\LinkA{runMI}{runMI}} function for further details.
\item[\code{package}] The package to be used in multiple imputation. The default value of this function is \code{"default"}. For the default option, if \code{m} is 0, the full information maximum likelihood is used. If \code{m} is greater than 0, the Amelia package is used. The possible inputs are \code{"default"}, \code{"Amelia"}, or \code{"mice"}.
\item[\code{convergentCutoff}] If the proportion of convergent results across imputations are greater than the specified value (the default is 80\%), the analysis on the dataset is considered as convergent. Otherwise, the analysis is considered as nonconvergent. This attribute is applied for multiple imputation only. 
\item[\code{ignoreCols}] The columns not imposed any missing values for any missing data patterns
\item[\code{threshold}] The threshold of covariates that divide between the area to impose missing and the area not to impose missing. The default threshold is the mean of the covariate.
\item[\code{covAsAux}] If \code{TRUE}, the covariate listed in the object will be used as auxiliary variables when putting in the model object. If \code{FALSE}, the covariate will be included in the analysis.
\item[\code{logical}] A matrix of logical values (\code{TRUE/FALSE}). If a value in the dataset is corresponding to the \code{TRUE} in the logical matrix, the value will be missing.
\item[\code{...}] Additional arguments used in multiple imputation function. This feature currently does not work now.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A missing object that contains missing-data template (\code{\LinkA{SimMissing}{SimMissing.Rdash.class}})
\end{Value}
%
\begin{Author}\relax
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu}), 
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}), 
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimMissing}{SimMissing.Rdash.class}} The resulting missing object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#Example of imposing 10% MCAR missing in all variables with no imputations (FIML method)
Missing <- miss(pmMCAR=0.1, ignoreCols="group")
summary(Missing)

loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

#Create data
dat <- generate(CFA.Model, n = 20)

#Impose missing
datmiss <- impose(Missing, dat)

#Analyze data
out <- analyze(CFA.Model, datmiss)
summary(out)

#Missing using logistic regression
script <- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
	y4 ~ -2 + 0.1*y4
	y5 ~ -0.5' 
Missing2 <- miss(logit=script, pmMCAR=0.1, ignoreCols="group")
summary(Missing2)
datmiss2 <- impose(Missing2, dat)

#Missing using logistic regression (2)
script <- 'y1 ~ 0.05 + 0.5*y3
	y2 ~ p(0.2)
	y3 ~ p(0.1) + -1*y1
	y4 ~ p(0.3) + 0.2*y1 + -0.3*y2
	y5 ~ -0.5' 
Missing2 <- miss(logit=script)
summary(Missing2)
datmiss2 <- impose(Missing2, dat)

#Example to create simMissing object for 3 forms design at 3 timepoints with 10 imputations
Missing <- miss(nforms=3, timePoints=3, numImps=10)

#Missing template for data analysis with multiple imputation
Missing <- miss(package="mice", m=10, chi="all", convergentCutoff=0.6)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{model}{Data generation template and analysis template for simulation.}{model}
\methaliasA{model.cfa}{model}{model.cfa}
\methaliasA{model.path}{model}{model.path}
\methaliasA{model.sem}{model}{model.sem}
%
\begin{Description}\relax
This function creates a model template (lavaan parameter table), which can be used for data generation and/or analysis for simulated structural equation modeling using simsem. Models are specified using Y-side parameter matrices with LISREL syntax notation. Each parameter matrix must be a \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}} built using \code{bind}. In addition to the usual Y-side matrices in LISREL, both PS and TE can be specified using correlation matrices (RPS, RTE) and scaled by a vector of residual variances (VTE, VPS) or total variances (VY, VE). Multiple group models can be created by passing lists of \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}} to arguments, or by simply specifying the number of groups when all group models are identical. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
model(LY = NULL, PS = NULL, RPS = NULL, TE = NULL, RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE = NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, modelType, indLab = NULL, facLab = NULL, 
	covLab = NULL, groupLab = "group", ngroups = 1, con = NULL)
model.cfa(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, VTE = NULL, 
	VY = NULL, VPS = NULL, VE=NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, 
	KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
model.path(PS = NULL, RPS = NULL, BE = NULL, VPS = NULL, VE=NULL, AL = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
model.sem(LY = NULL,PS = NULL,RPS = NULL, TE = NULL,RTE = NULL, BE = NULL, 
	VTE = NULL, VY = NULL, VPS = NULL, VE=NULL, TY = NULL, AL = NULL, MY = NULL, 
	ME = NULL, KA = NULL, GA = NULL, indLab = NULL, facLab = NULL, covLab = NULL, 
	groupLab = "group", ngroups = 1, con = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{LY}] 
Factor loading matrix from endogenous factors to Y indicators (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object).

\item[\code{PS}] 
Residual variance-covariance matrix among endogenous factors (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). Either RPS or PS (but not both) must be specified in SEM and CFA models.

\item[\code{RPS}] 
Residual correlation matrix among endogenous factors (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). Either RPS or PS (but not both) must be specified in SEM and CFA models.

\item[\code{TE}] 
Measurement error variance-covariance matrix among Y indicators (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). Either RTE or TE (but not both) must be specified in SEM and CFA models.

\item[\code{RTE}] 
Measurement error correlation matrix among Y indicators (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). Either RTE or TE (but not both) must be specified in SEM and CFA models.

\item[\code{BE}] 
Regression coefficient matrix among endogenous factors (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). BE must be specified in path analysis and SEM models. 

\item[\code{VTE}] 
Measurement error variance of indicators (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either VTE or VY (but not both) can be specified when RTE (instead of TE) is specified.

\item[\code{VY}] 
Total variance of indicators (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either VTE or VY (but not both) can be specified when RTE (instead of TE) is specified.

\item[\code{VPS}] 
Residual variance of factors (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either VPS or VE (but not both) can be specified when RPS (instead of PS) is specified.

\item[\code{VE}] 
Total variance of of factors (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either VPS or VE (but not both) can be specified when RPS (instead of PS) is specified.
 
\item[\code{TY}] 
Measurement intercepts of Y indicators (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either TY or MY (but not both) can be specified. 

\item[\code{AL}] 
Endogenous factor intercepts (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either AL or ME (but not both) can be specified. 

\item[\code{MY}] 
Y indicator means (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). Either TY or MY (but not both) can be specified. 

\item[\code{ME}] 
Total mean of endogenous factors (must be \code{\LinkA{SimVector}{SimVector.Rdash.class}} object). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.

\item[\code{KA}] 
Regression coefficient matrix from covariates to indicators (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). KA is needed when (fixed) exogenous covariates are needed only.

\item[\code{GA}] 
Regression coefficient matrix from covariates to factors (must be \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} object). GA is needed when (fixed) exogenous covariates are needed only.

\item[\code{modelType}] 
"CFA", "Sem", or "Path". Model type must be specified to ensure that the matrices specified in model templates for data generation and analysis correspond to what the user intends.

\item[\code{indLab}] 
Character vector of indicator labels. If left blank, automatic labels will be generated as  \code{y1}, \code{y2}, ... \code{yy}.

\item[\code{facLab}]  
Character vector of factor labels. If left blank, automatic labels will be generated as \code{f1}, \code{f2}, ... \code{ff}

\item[\code{covLab}]  
Character vector of covariate labels. If left blank, automatic labels will be generated as \code{z1}, \code{z2}, ... \code{zz}

\item[\code{groupLab}] 
Character of group-variable label (not the names of each group). If left blank, automatic labels will be generated as \code{group}

\item[\code{ngroups}] 
Number of groups for data generation (defaults to 1). Should only be specified for multiple group models in which all parameter matrices are identical across groups (when ngroups > 1, specified matrices are replicated for all groups). For multiple group models in which parameter matrices differ among groups, parameter matrices should instead be specified as a list (if any matrix argument is a list, the number of groups will be equal to the list's length, and the ngroups argument will be ignored).

\item[\code{con}] 
Additional parameters (phantom variables), equality constraints, and inequality constraints. Additional parameters must be specified using lavaan syntax. Allowed operators are ":=" (is defined as), "==" (is equal to), "<" (is less than), and ">" (is greater than). Names used in syntax must correspond to labels defined on free parameters in the model (with the exception that the name to the left of ":=" is a new parameter name). On the right hand side of all operators, any mathematical expressions are allowed, e.g., \code{"newparam := (load1 + load2 + load3)/3"}. For the "<" and ">" operators in data generation, if the specified relation is at odds with parameter specifications (e.g., the parameter to the left of the ">" operator is less that the parameter to the right), the left hand side parameter will be changed so that the relation holds with a very small difference (i.e., 0.000001). For example, in "load1 > load2", if load1 is 0.5 and load2 is 0.6, load1 will be changed to 0.6 + 0.000001 = 0.600001. 

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \emph{simsem} package is intricately tied to the \emph{lavaan} package for analysis of structural equation models. The analysis template that is generated by \code{model} is a lavaan parameter table, a low-level access point to lavaan that allows repeated analyses to happen more rapidly. If desired, the parameter table generated can be used directly with lavaan for many analyses.

The data generation template is simply a list of \code{SimMatrix} or \code{SimVector} objects. The \code{SimSem} object can be passed to the function \code{generate} to generate data, or can be passed to the function \code{sim} to generate and/or analyze data.

To simulate multiple group data, users can either specify a integer in the ngroups argument (which creates a list of identical model arguments for each group), or pass a list of  \code{SimMatrix} or \code{SimVector} to any of the matrix arguments with length(s) equal to the number of groups desired (this approach will cause the ngroups argument to be ignored). If only one argument is a list, all other arguments will be replicated across groups (with the same parameter identification, population parameter values/distributions, and misspecification). If equality constraints are specified, these parameters will be constrained to be equal across groups.	

The \code{model.cfa}, \code{model.path}, and \code{model.sem} are the shortcuts for the \code{model} function when \code{modelType} are \code{"CFA"}, \code{"Path"}, and \code{"SEM"}, respectively.
\end{Details}
%
\begin{Value}
\code{SimSem} object that contains the data generation template (\code{@dgen}) and analysis template (\code{@pt}).
\end{Value}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}), 
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}
\item \code{\LinkA{sim}{sim}} for simulations using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{generate}{generate}} To generate data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{analyze}{analyze}} To analyze real or generated data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{draw}{draw}} To draw parameters using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Example 1: Confirmatory factor analysis
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# Example 2: Multiple-group CFA with weak invariance
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- paste0("con", 1:3)
loading[4:6, 2] <- paste0("con", 4:6)
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VTE <- bind(rep(NA, 6), 0.51)

CFA.Model <- model(LY = LY, RPS = list(RPS, RPS), RTE = list(RTE, RTE), VTE=list(VTE, VTE), 
	ngroups=2, modelType = "CFA")

# Example 3: Linear growth curve model with model misspecification
factor.loading <- matrix(NA, 4, 2)
factor.loading[,1] <- 1
factor.loading[,2] <- 0:3
LY <- bind(factor.loading)

factor.mean <- rep(NA, 2)
factor.mean.starting <- c(5, 2)
AL <- bind(factor.mean, factor.mean.starting)

factor.var <- rep(NA, 2)
factor.var.starting <- c(1, 0.25)
VPS <- bind(factor.var, factor.var.starting)

factor.cor <- matrix(NA, 2, 2)
diag(factor.cor) <- 1
RPS <- binds(factor.cor, 0.5)

VTE <- bind(rep(NA, 4), 1.2)

RTE <- binds(diag(4))

TY <- bind(rep(0, 4))

LCA.Model <- model(LY=LY, RPS=RPS, VPS=VPS, AL=AL, VTE=VTE, RTE=RTE, TY=TY, modelType="CFA")

# Example 4: Path analysis model with misspecified direct effect
path.BE <- matrix(0, 4, 4)
path.BE[3, 1:2] <- NA
path.BE[4, 3] <- NA
starting.BE <- matrix("", 4, 4)
starting.BE[3, 1:2] <- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] <- "runif(1,0.5,0.7)"
mis.path.BE <- matrix(0, 4, 4)
mis.path.BE[4, 1:2] <- "runif(1,-0.1,0.1)"
BE <- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error <- diag(4)
residual.error[1,2] <- residual.error[2,1] <- NA
RPS <- binds(residual.error, "rnorm(1,0.3,0.1)")

ME <- bind(rep(NA, 4), 0)

Path.Model <- model(RPS = RPS, BE = BE, ME = ME, modelType="Path")

# Example 5: Full SEM model 
loading <- matrix(0, 8, 3)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[7:8, 3] <- "con1"
loading.start <- matrix("", 8, 3)
loading.start[1:3, 1] <- 0.7
loading.start[4:6, 2] <- 0.7
loading.start[7:8, 3] <- "rnorm(1,0.6,0.05)"
LY <- bind(loading, loading.start)

RTE <- binds(diag(8))

factor.cor <- diag(3)
factor.cor[1, 2] <- factor.cor[2, 1] <- NA
RPS <- binds(factor.cor, 0.5)

path <- matrix(0, 3, 3)
path[3, 1:2] <- NA
path.start <- matrix(0, 3, 3)
path.start[3, 1] <- "rnorm(1,0.6,0.05)"
path.start[3, 2] <- "runif(1,0.3,0.5)"
BE <- bind(path, path.start)

SEM.model <- model(BE=BE, LY=LY, RPS=RPS, RTE=RTE, modelType="SEM")

# Shortcut example
SEM.model <- model.sem(BE=BE, LY=LY, RPS=RPS, RTE=RTE)

# Example 6: Multiple Group Model
loading1 <- matrix(NA, 6, 1)
LY1 <- bind(loading1, 0.7)
loading2 <- matrix(0, 6, 2)
loading2[1:3, 1] <- NA
loading2[4:6, 2] <- NA
LY2 <- bind(loading2, 0.7)

latent.cor2 <- matrix(NA, 2, 2)
diag(latent.cor2) <- 1
RPS1 <- binds(as.matrix(1))
RPS2 <- binds(latent.cor2, 0.5)

RTE <- binds(diag(6))

VTE <- bind(rep(NA, 6), 0.51)

noninvariance <- model(LY = list(LY1, LY2), RPS = list(RPS1, RPS2), RTE = list(RTE, RTE), 
	VTE=list(VTE, VTE), ngroups=2, modelType = "CFA")

# Example 7: Inequality Constraints

loading.in <- matrix(0, 6, 2)
loading.in[1:3, 1] <- c("load1", "load2", "load3")
loading.in[4:6, 2] <- c("load4", "load5", "load6")
mis <- matrix(0,6,2)
mis[loading.in == "0"] <- "runif(1, -0.1, 0.1)"
LY.in <- bind(loading.in, "runif(1, 0.7, 0.8)", mis)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VTE <- bind(rep(NA, 6), 0.51)

VPS1 <- bind(rep(1, 2))

VPS2 <- bind(rep(NA, 2), c(1.1, 1.2))

# Inequality constraint
script <- "
sth := load1 + load2 + load3
load4 == (load5 + load6) / 2
load4 > 0
load5 > 0
sth2 := load1 - load2
"

# Model Template
weak <- model(LY = LY.in, RPS = RPS, VPS=list(VPS1, VPS2), RTE = RTE, VTE=VTE, ngroups=2, 
	modelType = "CFA", con=script)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{model.lavaan}{Build the data generation template and analysis template from the lavaan result}{model.lavaan}
%
\begin{Description}\relax
Creates a data generation and analysis template (lavaan parameter table) for simulations with the \code{\LinkA{lavaan}{lavaan.Rdash.class}} result. Model misspecification may be added into the template by a vector, a matrix, or a list of vectors or matrices (for multiple groups). 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
model.lavaan(object, std = FALSE, LY = NULL, PS = NULL, RPS = NULL, 
	TE = NULL, RTE = NULL, BE = NULL, VTE = NULL, VY = NULL, VPS = NULL, 
	VE=NULL, TY = NULL, AL = NULL, MY = NULL, ME = NULL, KA = NULL, 
	GA = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
A \code{\LinkA{lavaan}{lavaan.Rdash.class}} object to be used to build the data generation and analysis template.

\item[\code{std}] 
If TRUE, use the resulting standardized parameters for data generation. If FALSE, use the unstandardized parameters for data generation.

\item[\code{LY}] 
Model misspecification in factor loading matrix from endogenous factors to Y indicators (need to be a matrix or a list of matrices).

\item[\code{PS}] 
Model misspecification in residual covariance matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{RPS}] 
Model misspecification in residual correlation matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{TE}] 
Model misspecification in measurement error covariance matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{RTE}] 
Model misspecification in measurement error correlation matrix among Y indicators (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{BE}] 
Model misspecification in regression coefficient matrix among endogenous factors (need to be a symmetric matrix or a list of symmetric matrices).

\item[\code{VTE}] 
Model misspecification in measurement error variance of indicators (need to be a vector or a list of vectors).

\item[\code{VY}] 
Model misspecification in total variance of indicators (need to be a vector or a list of vectors). NOTE: Either measurement error variance or indicator variance is specified. Both cannot be simultaneously specified.

\item[\code{VPS}] 
Model misspecification in residual variance of factors (need to be a vector or a list of vectors).

\item[\code{VE}] 
Model misspecification in total variance of of factors (need to be a vector or a list of vectors). NOTE: Either residual variance of factors or total variance of factors is specified. Both cannot be simulatneously specified.
 
\item[\code{TY}] 
Model misspecification in measurement intercepts of Y indicators. (need to be a vector or a list of vectors).

\item[\code{AL}] 
Model misspecification in endogenous factor intercept (need to be a vector or a list of vectors).

\item[\code{MY}] 
Model misspecification in overall Y indicator means. (need to be a vector or a list of vectors). NOTE: Either measurement intercept of indicator mean can be specified. Both cannot be specified simultaneously.

\item[\code{ME}] 
Model misspecification in total mean of endogenous factors (need to be a vector or a list of vectors). NOTE: Either endogenous factor intercept or total mean of endogenous factor is specified. Both cannot be simultaneously specified.

\item[\code{KA}] 
Model misspecification in regression coefficient matrix from covariates to indicators (need to be a matrix or a list of matrices). KA is applicable when exogenous covariates are specified only.

\item[\code{GA}] 
Model misspecification in regression coefficient matrix from covariates to factors (need to be a matrix or a list of matrices). KA is applicable when exogenous covariates are specified only.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{SimSem} object that contains the data generation template (\code{@dgen}) and analysis template (\code{@pt}).
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{model}{model}} To build data generation and data analysis template for simulation.
\item \code{\LinkA{sim}{sim}} for simulations using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{generate}{generate}} To generate data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{analyze}{analyze}} To analyze real or generated data using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.
\item \code{\LinkA{draw}{draw}} To draw parameters using the \code{\LinkA{SimSem}{SimSem.Rdash.class}} template.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
HS.model <- ' visual  =~ x1 + x2 + x3
             textual =~ x4 + x5 + x6
             speed   =~ x7 + x8 + x9 '

fit <- cfa(HS.model, data=HolzingerSwineford1939)

# Create data generation and data analysis model from lavaan
# Data generation is based on standardized parameters
datamodel1 <- model.lavaan(fit, std=TRUE)

# Data generation is based on unstandardized parameters
datamodel2 <- model.lavaan(fit, std=FALSE)

# Data generation model with misspecification on cross-loadings
crossload <- matrix("runif(1, -0.1, 0.1)", 9, 3)
crossload[1:3, 1] <- 0
crossload[4:6, 2] <- 0
crossload[7:9, 3] <- 0
datamodel3 <- model.lavaan(fit, std=TRUE, LY=crossload)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{multipleAllEqual}{Test whether all objects are equal}{multipleAllEqual}
%
\begin{Description}\relax
Test whether all objects are equal. The test is based on the \code{\LinkA{all.equal}{all.equal}} function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
multipleAllEqual(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
The target objects 

\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{TRUE} if all objects are equal.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
multipleAllEqual(1:5, 1:5, seq(2, 10, 2)/2) # Should be TRUE
multipleAllEqual(1:5, 1:6, seq(2, 10, 2)/2) # Should be FALSE
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotCIwidth}{Plot a confidence interval width of a target parameter}{plotCIwidth}
%
\begin{Description}\relax
Plot a confidence interval width of a target parameter
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotCIwidth(object, targetParam, assurance = 0.50, useContour = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The target (\code{\LinkA{SimResult}{SimResult.Rdash.class}} 

\item[\code{targetParam}] 
One or more target parameters to be plotted

\item[\code{assurance}] 
The percentile of the resulting width. When assurance is 0.50, the median of the widths is provided. See Lai \& Kelley (2011) for more details.

\item[\code{useContour}] 
If there are two things from varying sample size, varying percent completely at random, or varying percent missing at random, the \code{plotCutoff} function will provide 3D graph. A contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. The plot the confidence interval width is provided.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Lai, K., \& Kelley, K. (2011). Accuracy in parameter estimation for targeted effects in structural equation modeling: Sample size planning for narrow confidence intervals. \emph{Psychological Methods, 16}, 127-148.
\end{References}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCIwidth}{getCIwidth}} to get confidence interval widths 

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- 1
RTE <- binds(error.cor)
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=200, model=CFA.Model) 

# Plot the widths of factor correlation
plotCIwidth(Output, "f1~~f2", assurance = 0.80)

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 <- sim(NULL, n=seq(450, 500, 10), model=CFA.Model)

# Plot the widths along sample size value
plotCIwidth(Output2, "f1~~f2", assurance = 0.80)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output3 <- sim(NULL, n=seq(450, 500, 10), pmMCAR=c(0, 0.05, 0.1, 0.15), model=CFA.Model)

# Plot the contours that each contour represents the value of widths at each level
# of sample size and percent missing completely at random
plotCIwidth(Output3, "f1~~f2", assurance = 0.80)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotCoverage}{Make a plot of confidence interval coverage rates}{plotCoverage}
%
\begin{Description}\relax
Make a plot of confidence interval coverage rates given varying parameters (e.g., sample size, percent missing completely at random, or random parameters in the model)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotCoverage(object, coverParam, coverValue = NULL, contParam = NULL, contN = TRUE, 
    contMCAR = TRUE, contMAR = TRUE, useContour = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)

\item[\code{coverParam}] 
Vector of parameters names that the user wishes to find coverage rate for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2").

\item[\code{coverValue}] 
A target value used that users wish to find the coverage rate of that value (e.g., 0). If \code{NULL}, the parameter values will be used.

\item[\code{contParam}] 
Vector of parameters names that vary over replications that users wish to use in the plot.

\item[\code{contN}] 
Include the varying sample size in the coverage rate plot if available

\item[\code{contMCAR}] 
Include the varying MCAR (missing completely at random percentage) in the coverage rate plot if available

\item[\code{contMAR}] 
Include the varying MAR (missing at random percentage) in the coverage rate plot if available

\item[\code{useContour}] 
This argument is used when users specify to plot two varying parameters. If \code{TRUE}, the contour plot is used. If \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Predicting whether the confidence interval of each replication covers target value (or parameter) or not by varying parameters using logistic regression (without interaction). Then, plot the logistic curves predicting the probability of significance against the target varying parameters.
\end{Details}
%
\begin{Value}
Not return any value. This function will plot a graph only.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.
\item \code{\LinkA{getCoverage}{getCoverage}} to obtain a coverage rate given varying parameters values.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.4)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)

Output <- sim(NULL, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2), model=CFA.Model)

# Plot the power of the first factor loading along the sample size value
plotCoverage(Output, "f1=~y1", contMCAR=FALSE)
plotCoverage(Output, "f1=~y1", coverValue = 0, contMCAR=FALSE)

# Plot the power of the correlation along the sample size and percent missing completely at random
plotCoverage(Output, "f1=~y1")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotCutoff}{Plot sampling distributions of fit indices with fit indices cutoffs}{plotCutoff}
%
\begin{Description}\relax
This function will plot sampling distributions of fit indices. The users may add cutoffs by specifying the \code{alpha} level.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotCutoff(object, alpha = NULL, revDirec = FALSE, usedFit = NULL, 
	useContour = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The target (\code{\LinkA{SimResult}{SimResult.Rdash.class}} 

\item[\code{alpha}] 
A priori alpha level to get the cutoffs of fit indices

\item[\code{revDirec}] 
The default is to find critical point on the side that indicates worse fit (the right side of RMSEA or the left side of CFI). If specifying as \code{TRUE}, the directions are reversed.

\item[\code{usedFit}] 
The name of fit indices that researchers wish to plot

\item[\code{useContour}] 
If there are two things from varying sample size, varying percent completely at random, or varying percent missing at random, the \code{plotCutoff} function will provide 3D graph. A contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. The plot the fit indices distributions is provided.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoff}{getCutoff}} to find values of cutoffs based on null hypothesis sampling distributions only

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- 1
RTE <- binds(error.cor)
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=200, model=CFA.Model) 

# Plot the cutoffs with desired fit indices
plotCutoff(Output, 0.05, usedFit=c("RMSEA", "SRMR", "CFI", "TLI"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output2 <- sim(NULL, n=seq(450, 500, 10), model=CFA.Model)

# Plot the cutoffs along sample size value
plotCutoff(Output2, 0.05)

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)
Output3 <- sim(NULL, n=seq(450, 500, 10), pmMCAR=c(0, 0.05, 0.1, 0.15), model=CFA.Model)

# Plot the contours that each contour represents the value of cutoff at each level
# of sample size and percent missing completely at random
plotCutoff(Output3, 0.05)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotCutoffNested}{Plot sampling distributions of the differences in fit indices between nested models with fit indices cutoffs }{plotCutoffNested}
%
\begin{Description}\relax
This function will plot sampling distributions of the differences in fit indices between nested models if the nested model is true. The users may add cutoffs by specifying the \code{alpha} level.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotCutoffNested(nested, parent, alpha = 0.05, cutoff = NULL, 
usedFit = NULL, useContour = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of nested model from multiple replications

\item[\code{parent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of parent model from multiple replications

\item[\code{alpha}] 
A priori alpha level

\item[\code{cutoff}] 
A priori cutoffs for fit indices, saved in a vector

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to plot the sampling distribution. 

\item[\code{useContour}] 
If there are two of sample size, percent completely at random, and percent missing at random are varying, the \code{plotCutoff} function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. Only plot the fit indices distributions.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoffNested}{getCutoffNested}} to find the difference in fit indices cutoffs

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Nested model: One factor
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Parent model: two factors
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, "runif(1, 0.7, 0.9)")
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.NULL.NULL <- sim(10, n=500, model=CFA.Model.NULL) 
Output.NULL.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL)

# Plot the cutoffs in nested model comparison
plotCutoffNested(Output.NULL.NULL, Output.NULL.ALT, alpha=0.05)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotCutoffNonNested}{Plot sampling distributions of the differences in fit indices between non-nested models with fit indices cutoffs }{plotCutoffNonNested}
%
\begin{Description}\relax
This function will plot sampling distributions of the differences in fit indices between non-nested models. The users may add cutoffs by specifying the \code{alpha} level.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotCutoffNonNested(dat1Mod1, dat1Mod2, dat2Mod1=NULL, dat2Mod2=NULL, 
alpha=0.05, cutoff = NULL, usedFit = NULL, useContour = T, onetailed=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dat1Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1

\item[\code{dat1Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1

\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{alpha}] 
A priori alpha level

\item[\code{cutoff}] 
A priori cutoffs for fit indices, saved in a vector

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to plot the sampling distribution. 

\item[\code{useContour}] 
If there are two of sample size, percent completely at random, and percent missing at random are varying, the \code{plotCutoff} function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\item[\code{onetailed}] 
If \code{TRUE}, the function will find the cutoff from one-tail test. If \code{FALSE}, the funciton will find the cutoff from two-tailed test.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. Only plot the fit indices distributions.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoffNonNested}{getCutoffNonNested}} to find the difference in fit indices cutoffs for non-nested model comparison

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A <- matrix(0, 8, 2)
loading.A[1:3, 1] <- NA
loading.A[4:8, 2] <- NA
LY.A <- bind(loading.A, 0.7)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE <- binds(diag(8))
CFA.Model.A <- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B <- matrix(0, 8, 2)
loading.B[1:4, 1] <- NA
loading.B[5:8, 2] <- NA
LY.B <- bind(loading.B, 0.7)
CFA.Model.B <- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Plot cutoffs for both model A and model B
plotCutoffNonNested(Output.A.A, Output.A.B, Output.B.A, Output.B.B)

# Plot cutoffs for the model A only
plotCutoffNonNested(Output.A.A, Output.A.B)

# Plot cutoffs for the model A with one-tailed test
plotCutoffNonNested(Output.A.A, Output.A.B, onetailed=TRUE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotDist}{Plot a distribution of a data distribution object}{plotDist}
%
\begin{Description}\relax
Plot a distribution of a data distribution object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotDist(object, xlim = NULL, ylim = NULL, r = 0, var = NULL, contour = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The data distribution object (\code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}}) to plot a distribution 

\item[\code{xlim}] 
A numeric vector with two elements specifying the lower and upper limit of the x-axis to be plotted. 

\item[\code{ylim}] 
A numeric vector with two elements specifying the lower and upper limit of the y-axis to be plotted. This argument is applicable for the joint distribution of two dimensions only

\item[\code{r}] 
The correlation of two dimensions in the joint distribution

\item[\code{var}] 
A vector of the index of variables to be plotted. The length of vector cannot be greater than 2.

\item[\code{contour}] 
Applicable if two variables are used only. If TRUE, the contour plot is provided. If FALSE, the perspective plot is provided.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
No return value. This function will plot a graph only.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} for plotting a data distribution object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
datadist <- bindDist(c("chisq", "t", "f"), list(df=5), list(df=3), list(df1=3, df2=5))

# Plot the joint distribution of Variables 1 and 2 with correlation of 0.5
plotDist(datadist, r=0.5, var=1:2)

# Plot the marginal distribution of the variable 3
plotDist(datadist, var=3)

datadist2 <- bindDist(skewness = c(0, -2, 2), kurtosis = c(2, 4, 4))

# Plot the joint distribution of Variables 1 and 2 with correlation of 0.5
plotDist(datadist2, r=0.5, var=1:2)

# Plot the marginal distribution of the variable 3
plotDist(datadist2, var=3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotLogitMiss}{Visualize the missing proportion when the logistic regression method is used.}{plotLogitMiss}
%
\begin{Description}\relax
Visualize the missing proportion when the logistic regression method is used. The maximum number of independent variables is 2. The extra independent variables will be fixed as a value (the default is 0).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotLogitMiss(script, ylim=c(0,1), x1lim=c(-3,3), x2lim=c(-3,3), otherx=0, 
	useContour=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{script}] 
The script used in specifying missing data using the logistic regression. See further details in the \code{logit} argument of the \code{\LinkA{miss}{miss}} function

\item[\code{ylim}] 
The range of missing proportion to be plotted.

\item[\code{x1lim}] 
The range of the first independent variable to be plotted

\item[\code{x2lim}] 
The range of the second independent variable to be plotted

\item[\code{otherx}] 
The value of the extra independent variables to be fixed as.

\item[\code{useContour}] 
If there are two or more independent variables, the function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
Not return any value. This function will plot a graph only. If the number of independent variable is 0, the bar graph is provided. If the number of independent variables is 1, the logistic curve is provided. If the number of independent variables is 2, contour or perspective plot is provided.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{miss}{miss}} to create the missing data template
\item \code{\LinkA{impose}{impose}} to impose missing data

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
script <- 'y1 ~ 0.05 + 0.1*y2 + 0.3*y3
	y4 ~ -2 + 0.1*y4
	y5 ~ -0.5' 
plotLogitMiss(script)

script2 <- 'y1 ~ 0.05 + 0.5*y3
	y2 ~ p(0.2)
	y3 ~ p(0.1) + -1*y1
	y4 ~ p(0.3) + 0.2*y1 + -0.3*y2
	y5 ~ -0.5' 
plotLogitMiss(script2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotMisfit}{Plot the population misfit in the result object}{plotMisfit}
%
\begin{Description}\relax
Plot a histogram of the amount of population misfit in parameter result object or the scatter plot of the relationship between misspecified parameter and the population misfit or the fit indices
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotMisfit(object, usedFit="default", misParam=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The result object, \code{\LinkA{SimResult}{SimResult.Rdash.class}}

\item[\code{usedFit}] 
The sample fit indices or population misfit used to plot. All sample fit indices are available. The available population misfit are \code{"pop.f0"}, \code{"pop.rmsea"}, and \code{"pop.srmr"}. If the \code{misParam} is not specified, all population misfit are used. If the \code{misParam} is specified, the \code{"pop.rmsea"} is used in the plot.

\item[\code{misParam}] 
The index or the name of misspecified parameters used to plot.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
None. This function will plot only.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
path.BE <- matrix(0, 4, 4)
path.BE[3, 1:2] <- NA
path.BE[4, 3] <- NA
starting.BE <- matrix("", 4, 4)
starting.BE[3, 1:2] <- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] <- "runif(1, 0.5, 0.7)"
mis.path.BE <- matrix(0, 4, 4)
mis.path.BE[4, 1:2] <- "runif(1, -0.1, 0.1)"
BE <- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error <- diag(4)
residual.error[1,2] <- residual.error[2,1] <- NA
RPS <- binds(residual.error, "rnorm(1, 0.3, 0.1)")

ME <- bind(rep(NA, 4), 0)

Path.Model <- model(RPS = RPS, BE = BE, ME = ME, modelType="Path")

# The number of replications in actual analysis should be much more than 20
Output <- sim(20, n=500, Path.Model)

# Plot the distribution of population misfit
plotMisfit(Output)

# Plot the relationship between population RMSEA and all misspecified direct effects
plotMisfit(Output, misParam=1:2)

# Plot the relationship between sample CFI and all misspecified direct effects 
plotMisfit(Output, usedFit="CFI", misParam=1:2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotPower}{Make a power plot of a parameter given varying parameters}{plotPower}
%
\begin{Description}\relax
Make a power plot of a parameter given varying parameters (e.g., sample size, percent missing completely at random, or random parameters in the model)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotPower(object, powerParam, alpha = 0.05, contParam = NULL, contN = TRUE, 
	contMCAR = TRUE, contMAR = TRUE, useContour=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that includes at least one randomly varying parameter (e.g. sample size, percent missing, model parameters)

\item[\code{powerParam}] 
Vector of parameters names that the user wishes to find power for. This can be a vector of names (e.g., "f1=\textasciitilde{}y2", "f1\textasciitilde{}\textasciitilde{}f2").

\item[\code{alpha}] 
Alpha level to use for power analysis.

\item[\code{contParam}] 
Vector of parameters names that vary over replications that users wish to use in the plot.

\item[\code{contN}] 
Include the varying sample size in the power plot if available

\item[\code{contMCAR}] 
Include the varying MCAR (missing completely at random percentage) in the power plot if available

\item[\code{contMAR}] 
Include the varying MAR (missing at random percentage) in the power plot if available

\item[\code{useContour}] 
This argument is used when users specify to plot two varying parameters. If \code{TRUE}, the contour plot is used. If \code{FALSE}, perspective plot is used.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Predicting whether each replication is significant or not by varying parameters using logistic regression (without interaction). Then, plot the logistic curves predicting the probability of significance against the target varying parameters.
\end{Details}
%
\begin{Value}
Not return any value. This function will plot a graph only.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu}), Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to see how to create a simResult object with randomly varying parameters.
\item \code{\LinkA{getPower}{getPower}} to obtain a statistical power given varying parameters values.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.4)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# Specify both continuous sample size and percent missing completely at random. 
# Note that more fine-grained values of n and pmMCAR is needed, e.g., n=seq(50, 500, 1) 
# and pmMCAR=seq(0, 0.2, 0.01)

Output <- sim(NULL, n=seq(100, 200, 20), pmMCAR=c(0, 0.1, 0.2), model=CFA.Model)

# Plot the power of the first factor loading along the sample size value
plotPower(Output, "f1=~y1", contMCAR=FALSE)

# Plot the power of the correlation along the sample size and percent missing completely at random
plotPower(Output, "f1=~y1")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotPowerFit}{Plot sampling distributions of fit indices that visualize power of rejecting datasets underlying misspecified models}{plotPowerFit}
%
\begin{Description}\relax
This function will plot sampling distributions of fit indices that visualize power in rejecting the misspecified models
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotPowerFit(altObject, nullObject = NULL, cutoff = NULL, usedFit = NULL, 
alpha = 0.05, contN = TRUE, contMCAR = TRUE, contMAR = TRUE, 
useContour = TRUE, logistic = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{altObject}] 
The result object (\code{\LinkA{SimResult}{SimResult.Rdash.class}}) saves the simulation result of fitting the hypothesized model when the hypothesized model is \code{FALSE}.

\item[\code{nullObject}] 
The result object (\code{\LinkA{SimResult}{SimResult.Rdash.class}}) saves the simulation result of fitting the hypothesized model when the hypothesized model is \code{TRUE}. This argument may be not specified if the \code{cutoff} is specified.

\item[\code{cutoff}] 
A vector of priori cutoffs for fit indices.

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to plot.

\item[\code{alpha}] 
A priori alpha level

\item[\code{contN}] 
Include the varying sample size in the power plot if available

\item[\code{contMCAR}] 
Include the varying MCAR (missing completely at random percentage) in the power plot if available

\item[\code{contMAR}] 
Include the varying MAR (missing at random percentage) in the power plot if available

\item[\code{useContour}] 
If there are two of sample size, percent completely at random, and percent missing at random are varying, the \code{plotCutoff} function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\item[\code{logistic}] 
If \code{logistic} is \code{TRUE} and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If \code{FALSE}, the overlaying scatterplot with a line of cutoff is plotted.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. Only plot the fit indices distributions.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoff}{getCutoff}} to find values of cutoffs based on null hypothesis sampling distributions only
\item \code{\LinkA{getPowerFit}{getPowerFit}} to find power of rejecting the hypothesized model when the hypothesized model is \code{FALSE}.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Null model: One factor model
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output.NULL <- sim(50, n=50, model=CFA.Model.NULL, generate=CFA.Model.NULL) 

# Alternative model: Two-factor model
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, 0.5)
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")
Output.ALT <- sim(50, n=50, model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Plot the power based on derived cutoff from the null model using four fit indices
plotPowerFit(Output.ALT, nullObject=Output.NULL, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# Plot the power of rejecting null model when the rule of thumb from Hu & Bentler (1999) is used
Rule.of.thumb <- c(RMSEA=0.05, CFI=0.95, TLI=0.95, SRMR=0.06)
plotPowerFit(Output.ALT, cutoff=Rule.of.thumb, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL2 <- sim(NULL, n=seq(50, 250, 25), model=CFA.Model.NULL, generate=CFA.Model.NULL)
Output.ALT2 <- sim(NULL, n=seq(50, 250, 25), model=CFA.Model.NULL, generate=CFA.Model.ALT)

# Plot the power based on derived cutoff from the null model using four fit indices 
# along sample size
plotPowerFit(Output.ALT2, nullObject=Output.NULL2, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

# Plot the power based on rule of thumb along sample size
plotPowerFit(Output.ALT2, cutoff=Rule.of.thumb, alpha=0.05, 
	usedFit=c("RMSEA", "CFI", "TLI", "SRMR"))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotPowerFitNested}{Plot power of rejecting a nested model in a nested model comparison by each fit index }{plotPowerFitNested}
%
\begin{Description}\relax
This function will plot sampling distributions of the differences in fit indices between parent and nested models. Two sampling distributions will be compared: nested model is \code{FALSE} (alternative model) and nested model is \code{TRUE} (null model). 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotPowerFitNested(altNested, altParent, nullNested = NULL, 
nullParent = NULL, cutoff = NULL, usedFit = NULL, alpha = 0.05, 
contN = TRUE, contMCAR = TRUE, contMAR = TRUE, useContour = TRUE, 
logistic = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{altNested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the nested model when the nested model is \code{FALSE}.

\item[\code{altParent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the parent model when the nested model is \code{FALSE}.

\item[\code{nullNested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the nested model when the nested model is \code{TRUE}. This argument may not be specified if the \code{cutoff} is specified.

\item[\code{nullParent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation result of the parent model when the nested model is \code{TRUE}. This argument may not be specified if the \code{cutoff} is specified.

\item[\code{cutoff}] 
A vector of priori cutoffs for the differences in fit indices.

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to plot.

\item[\code{alpha}] 
A priori alpha level

\item[\code{contN}] 
Include the varying sample size in the power plot if available

\item[\code{contMCAR}] 
Include the varying MCAR (missing completely at random percentage) in the power plot if available

\item[\code{contMAR}] 
Include the varying MAR (missing at random percentage) in the power plot if available

\item[\code{useContour}] 
If there are two of sample size, percent completely at random, and percent missing at random are varying, the \code{plotCutoff} function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\item[\code{logistic}] 
If \code{logistic} is \code{TRUE} and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If \code{FALSE}, the overlaying scatterplot with a line of cutoff is plotted.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. Only plot the fit indices distributions.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoffNested}{getCutoffNested}} to find the cutoffs of the differences in fit indices
\item \code{\LinkA{plotCutoffNested}{plotCutoffNested}} to visualize the cutoffs of the differences in fit indices
\item \code{\LinkA{getPowerFitNested}{getPowerFitNested}} to find the power in rejecting the nested model by the difference in fit indices cutoffs

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Null model: One-factor model
loading.null <- matrix(0, 6, 1)
loading.null[1:6, 1] <- NA
LY.NULL <- bind(loading.null, 0.7)
RPS.NULL <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model.NULL <- model(LY = LY.NULL, RPS = RPS.NULL, RTE = RTE, modelType="CFA")

# Alternative model: Two-factor model
loading.alt <- matrix(0, 6, 2)
loading.alt[1:3, 1] <- NA
loading.alt[4:6, 2] <- NA
LY.ALT <- bind(loading.alt, 0.7)
latent.cor.alt <- matrix(NA, 2, 2)
diag(latent.cor.alt) <- 1
RPS.ALT <- binds(latent.cor.alt, 0.7)
CFA.Model.ALT <- model(LY = LY.ALT, RPS = RPS.ALT, RTE = RTE, modelType="CFA")

# In reality, more than 10 replications are needed
Output.NULL.NULL <- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL <- sim(10, n=500, model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT <- sim(10, n=500, model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Plot the power based on the derived cutoff from the models analyzed on the null datasets
plotPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT)

# Plot the power by only CFI
plotPowerFitNested(Output.ALT.NULL, Output.ALT.ALT, nullNested=Output.NULL.NULL, 
	nullParent=Output.NULL.ALT, usedFit="CFI")

# The example of continous varying sample size. Note that more fine-grained 
# values of n is needed, e.g., n=seq(50, 500, 1)
Output.NULL.NULL2 <- sim(NULL, n=seq(50, 500, 25), model=CFA.Model.NULL, generate=CFA.Model.NULL) 
Output.ALT.NULL2 <- sim(NULL, n=seq(50, 500, 25), model=CFA.Model.NULL, generate=CFA.Model.ALT) 
Output.NULL.ALT2 <- sim(NULL, n=seq(50, 500, 25), model=CFA.Model.ALT, generate=CFA.Model.NULL) 
Output.ALT.ALT2 <- sim(NULL, n=seq(50, 500, 25), model=CFA.Model.ALT, generate=CFA.Model.ALT) 

# Plot logistic line for the power based on the derived cutoff from the null model 
# along sample size values
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2)

# Plot scatterplot for the power based on the derived cutoff from the null model 
# along sample size values
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, nullNested=Output.NULL.NULL2, 
	nullParent=Output.NULL.ALT2, logistic=FALSE)

# Plot scatterplot for the power based on the advanced CFI value
plotPowerFitNested(Output.ALT.NULL2, Output.ALT.ALT2, cutoff=c(CFI=-0.1), logistic=FALSE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotPowerFitNonNested}{Plot power of rejecting a non-nested model based on a difference in fit index }{plotPowerFitNonNested}
%
\begin{Description}\relax
Plot the proportion of the difference in fit indices from one model that does not in the range of sampling distribution from another model (reject that the dataset comes from the second model) or indicates worse fit than a specified cutoff. This plot can show the proportion in the second model that does not in the range of sampling distribution from the first model too.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotPowerFitNonNested(dat2Mod1, dat2Mod2, dat1Mod1=NULL, dat1Mod2=NULL, 
cutoff = NULL, usedFit = NULL, alpha = 0.05, contN = TRUE, contMCAR = TRUE, 
contMAR = TRUE, useContour = TRUE, logistic = TRUE, onetailed = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{dat1Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1

\item[\code{dat1Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1

\item[\code{cutoff}] 
A vector of priori cutoffs for the differences in fit indices.

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to plot.

\item[\code{alpha}] 
A priori alpha level

\item[\code{contN}] 
Include the varying sample size in the power plot if available

\item[\code{contMCAR}] 
Include the varying MCAR (missing completely at random percentage) in the power plot if available

\item[\code{contMAR}] 
Include the varying MAR (missing at random percentage) in the power plot if available

\item[\code{useContour}] 
If there are two of sample size, percent completely at random, and percent missing at random are varying, the \code{plotCutoff} function will provide 3D graph. Contour graph is a default. However, if this is specified as \code{FALSE}, perspective plot is used.

\item[\code{logistic}] 
If \code{logistic} is \code{TRUE} and the varying parameter exists (e.g., sample size or percent missing), the plot based on logistic regression predicting the significance by the varying parameters is preferred. If \code{FALSE}, the overlaying scatterplot with a line of cutoff is plotted.

\item[\code{onetailed}] 
If \code{TRUE}, the function will use the cutoff from one-tail test. If \code{FALSE}, the funciton will use the cutoff from two-tailed test.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. Only plot the fit indices distributions.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for simResult that used in this function.
\item \code{\LinkA{getCutoffNonNested}{getCutoffNonNested}} to find the cutoffs of the differences in fit indices for non-nested model comparison
\item \code{\LinkA{plotCutoffNonNested}{plotCutoffNonNested}} to visualize the cutoffs of the differences in fit indices for non-nested model comparison
\item \code{\LinkA{getPowerFitNonNested}{getPowerFitNonNested}} to find the power in rejecting the non-nested model by the difference in fit indices cutoffs

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A: Factor 1 on Items 1-3 and Factor 2 on Items 4-8
loading.A <- matrix(0, 8, 2)
loading.A[1:3, 1] <- NA
loading.A[4:8, 2] <- NA
LY.A <- bind(loading.A, 0.7)
latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, "runif(1, 0.7, 0.9)")
RTE <- binds(diag(8))
CFA.Model.A <- model(LY = LY.A, RPS = RPS, RTE = RTE, modelType="CFA")

# Model B: Factor 1 on Items 1-4 and Factor 2 on Items 5-8
loading.B <- matrix(0, 8, 2)
loading.B[1:4, 1] <- NA
loading.B[5:8, 2] <- NA
LY.B <- bind(loading.B, 0.7)
CFA.Model.B <- model(LY = LY.B, RPS = RPS, RTE = RTE, modelType="CFA")

# The actual number of replications should be greater than 10.
Output.A.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.A)
Output.A.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.A)
Output.B.A <- sim(10, n=500, model=CFA.Model.A, generate=CFA.Model.B)
Output.B.B <- sim(10, n=500, model=CFA.Model.B, generate=CFA.Model.B)

# Plot the power based on the derived cutoff for both models
plotPowerFitNonNested(Output.B.A, Output.B.B, dat1Mod1=Output.A.A, dat1Mod2=Output.A.B)

# Plot the power based on AIC and BIC cutoffs
plotPowerFitNonNested(Output.B.A, Output.B.B, cutoff=c(AIC=0, BIC=0))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popDiscrepancy}{Find the discrepancy value between two means and covariance matrices}{popDiscrepancy}
%
\begin{Description}\relax
Find the discrepancy value between two means and covariance matrices. See the definition of each index at \code{\LinkA{summaryMisspec}{summaryMisspec}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popDiscrepancy(paramM, paramCM, misspecM, misspecCM)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{paramM}] 
The model-implied mean from the real parameters

\item[\code{paramCM}] 
The model-implied covariance matrix from the real parameters

\item[\code{misspecM}] 
The model-implied mean from the real and misspecified parameters

\item[\code{misspecCM}] 
The model-implied covariance matrix from the real and misspecified parameters

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The discrepancy between two means and covariance matrices
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Browne, M. W., \& Cudeck, R. (1992). Alternative ways of assessing model fit. \emph{Sociological Methods \& Research, 21}, 230-258.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
m1 <- rep(0, 3)
m2 <- c(0.1, -0.1, 0.05)
S1 <- matrix(c(1, 0.6, 0.5, 0.6, 1, 0.4, 0.5, 0.4, 1), 3, 3)
S2 <- matrix(c(1, 0.55, 0.55, 0.55, 1, 0.55, 0.55, 0.55, 1), 3, 3)
popDiscrepancy(m1, S1, m2, S2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popMisfitMACS}{Find population misfit by sufficient statistics}{popMisfitMACS}
%
\begin{Description}\relax
Find the value quantifying the amount of population misfit: \eqn{F_0}{}, RMSEA, and SRMR. See the definition of each index at \code{\LinkA{summaryMisspec}{summaryMisspec}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popMisfitMACS(paramM, paramCM, misspecM, misspecCM, dfParam=NULL, fit.measures="all")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{paramM}] 
The model-implied mean from the real parameters

\item[\code{paramCM}] 
The model-implied covariance matrix from the real parameters

\item[\code{misspecM}] 
The model-implied mean from the real and misspecified parameters

\item[\code{misspecCM}] 
The model-implied covariance matrix from the real and misspecified parameters

\item[\code{dfParam}] 
The degree of freedom of the real model

\item[\code{fit.measures}] 
The names of indices used to calculate population misfit. There are three types of misfit: 1) discrepancy function (\code{"f0"}; see \code{\LinkA{popDiscrepancy}{popDiscrepancy}}), 2) root mean squared error of approximation (\code{"rmsea"}; Equation 12 in Browne \& Cudeck, 1992), and 3) standardized root mean squared residual (\code{"srmr"})

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The vector of the misfit indices
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Browne, M. W., \& Cudeck, R. (1992). Alternative ways of assessing model fit. \emph{Sociological Methods \& Research, 21}, 230-258.
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
m1 <- rep(0, 3)
m2 <- c(0.1, -0.1, 0.05)
S1 <- matrix(c(1, 0.6, 0.5, 0.6, 1, 0.4, 0.5, 0.4, 1), 3, 3)
S2 <- matrix(c(1, 0.55, 0.55, 0.55, 1, 0.55, 0.55, 0.55, 1), 3, 3)
popMisfitMACS(m1, S1, m2, S2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pValue}{Find p-values (1 - percentile) by comparing a single analysis output from the result object}{pValue}
%
\begin{Description}\relax
This function will provide \emph{p} value from comparing a \code{\LinkA{lavaan}{lavaan.Rdash.class}}) or a OpenMx result from the simulation result (in \code{\LinkA{SimResult}{SimResult.Rdash.class}}).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pValue(target, dist, usedFit = NULL, nVal = NULL, pmMCARval = NULL, 
	pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{target}] 
A value, multiple values, a lavaan object, or an OpenMx object used to find p values. This argument could be a cutoff of a fit index.

\item[\code{dist}] 
The comparison distribution, which can be a vector of numbers, a data frame, or a result object.

\item[\code{usedFit}] 
The vector of names of fit indices that researchers wish to find the \emph{p} value from.

\item[\code{nVal}] 
The sample size value that researchers wish to find the fit indices cutoffs from

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the fit indices cutoffs from.

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In comparing fit indices, the \emph{p} value is the proportion of the number of replications that provide poorer fit (e.g., less CFI value or greater RMSEA value) than the analysis result from the observed data. 
\end{Details}
%
\begin{Value}
The \emph{p} values of fit indices are provided, as well as two additional values: \code{andRule} and \code{orRule}. The \code{andRule} is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the \code{andRule} is the most stringent rule in retaining a hypothesized model. The \code{orRule} is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the \code{orRule} is the most lenient rule in retaining a hypothesized model.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to run a simulation study

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Compare an analysis result with a result of simulation study
library(lavaan)
loading <- matrix(0, 9, 3)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[7:9, 3] <- NA
targetmodel <- estmodel(LY=loading, modelType="CFA", indLab=paste("x", 1:9, sep=""))
out <- analyze(targetmodel, HolzingerSwineford1939)

loading.trivial <- matrix("runif(1, -0.2, 0.2)", 9, 3)
loading.trivial[is.na(loading)] <- 0
mismodel <- model.lavaan(out, std=TRUE, LY=loading.trivial)

# The actual number of replications should be much greater than 20.
simout <- sim(20, n=nrow(HolzingerSwineford1939), mismodel)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices
pValue(out, simout)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pValueNested}{Find p-values (1 - percentile) for a nested model comparison}{pValueNested}
%
\begin{Description}\relax
This function will provide \emph{p} value from comparing the differences in fit indices between nested models with the simulation results of both parent and nested models when the nested model is true. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pValueNested(outNested, outParent, simNested, simParent, usedFit = NULL, 
nVal = NULL, pmMCARval = NULL, pmMARval = NULL, df = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{outNested}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the nested model from the target dataset

\item[\code{outParent}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the parent model from the target dataset

\item[\code{simNested}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of nested model from multiple replications

\item[\code{simParent}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the analysis results of parent model from multiple replications

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.

\item[\code{nVal}] 
The sample size value that researchers wish to find the \emph{p} value from.

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the \emph{p} value from.

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the the \emph{p} value from.

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In comparing fit indices, the \emph{p} value is the proportion of the number of replications that provide less preference for nested model (e.g., larger negative difference in CFI values or larger positive difference in RMSEA values) than the analysis result from the observed data. 
\end{Details}
%
\begin{Value}
This function provides a vector of \emph{p} values based on the comparison of the difference in fit indices from the real data with the simulation result. The \emph{p} values of fit indices are provided, as well as two additional values: \code{andRule} and \code{orRule}. The \code{andRule} is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the \code{andRule} is the most stringent rule in retaining a hypothesized model. The \code{orRule} is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the \code{orRule} is the most lenient rule in retaining a hypothesized model.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}


\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to run a simulation study


\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
library(lavaan)

# Nested Model: Linear growth curve model
LY <- matrix(1, 4, 2)
LY[,2] <- 0:3
PS <- matrix(NA, 2, 2)
TY <- rep(0, 4)
AL <- rep(NA, 2)
TE <- diag(NA, 4)
nested <- estmodel(LY=LY, PS=PS, TY=TY, AL=AL, TE=TE, modelType="CFA", 
	indLab=paste("t", 1:4, sep=""))

# Parent Model: Unconditional growth curve model
LY2 <- matrix(1, 4, 2)
LY2[,2] <- c(0, NA, NA, 3)
parent <- estmodel(LY=LY2, PS=PS, TY=TY, AL=AL, TE=TE, modelType="CFA", 
	indLab=paste("t", 1:4, sep=""))

# Analyze the output
outNested <- analyze(nested, Demo.growth)
outParent <- analyze(parent, Demo.growth)

# Create data template from the nested model with small misfit on the linear curve
loadingMis <- matrix(0, 4, 2)
loadingMis[2:3, 2] <- "runif(1, -0.1, 0.1)"
datamodel <- model.lavaan(outNested, LY=loadingMis)

# Get the sample size
n <- nrow(Demo.growth)

# The actual replications should be much greater than 30.
simNestedNested <- sim(30, n=n, nested, generate=datamodel) 
simNestedParent <- sim(30, n=n, parent, generate=datamodel)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices
pValueNested(outNested, outParent, simNestedNested, simNestedParent)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pValueNonNested}{Find p-values (1 - percentile) for a non-nested model comparison}{pValueNonNested}
%
\begin{Description}\relax
This function will provide \emph{p} value from comparing the results of fitting real data into two models against the simulation from fitting the simulated data from both models into both models. The \emph{p} values from both sampling distribution under the datasets from the first and the second models are reported.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pValueNonNested(outMod1, outMod2, dat1Mod1, dat1Mod2, dat2Mod1, dat2Mod2, 
usedFit = NULL, nVal = NULL, pmMCARval = NULL, pmMARval = NULL, df = 0, 
onetailed=FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{outMod1}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the first model from the target dataset

\item[\code{outMod2}] 
\code{\LinkA{lavaan}{lavaan.Rdash.class}} that saves the analysis result of the second model from the target dataset

\item[\code{dat1Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 1

\item[\code{dat1Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 1

\item[\code{dat2Mod1}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 1 by datasets created from Model 2

\item[\code{dat2Mod2}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} that saves the simulation of analyzing Model 2 by datasets created from Model 2

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to getCutoffs from. The default is to getCutoffs of all fit indices.

\item[\code{nVal}] 
The sample size value that researchers wish to find the \emph{p} value from.

\item[\code{pmMCARval}] 
The percent missing completely at random value that researchers wish to find the \emph{p} value from.

\item[\code{pmMARval}] 
The percent missing at random value that researchers wish to find the the \emph{p} value from.

\item[\code{df}] 
The degree of freedom used in spline method in predicting the fit indices by the predictors. If \code{df} is 0, the spline method will not be applied.

\item[\code{onetailed}] 
If \code{TRUE}, the function will convert the \emph{p} value based on two-tailed test. 

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In comparing fit indices, the \emph{p} value is the proportion of the number of replications that provide less preference for either model 1 or model 2 than the analysis result from the observed data. In two-tailed test, the function will report the proportion of values under the sampling distribution that are more extreme that one obtained from real data. If the resulting \code{p} value is high (> .05) on one model and low (< .05) in the other model, the model with high \code{p} value is preferred. If the \code{p} values are both high or both low, the decision is undetermined.
\end{Details}
%
\begin{Value}
This function provides a vector of \emph{p} values based on the comparison of the difference in fit indices from the real data with the simulation results. The \emph{p} values of fit indices are provided, as well as two additional values: \code{andRule} and \code{orRule}. The \code{andRule} is based on the principle that the model is retained only when all fit indices provide good fit. The proportion is calculated from the number of replications that have all fit indices indicating a better model than the observed data. The proportion from the \code{andRule} is the most stringent rule in retaining a hypothesized model. The \code{orRule} is based on the principle that the model is retained only when at least one fit index provides good fit. The proportion is calculated from the number of replications that have at least one fit index indicating a better model than the observed data. The proportion from the \code{orRule} is the most lenient rule in retaining a hypothesized model.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}


\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} to run a simulation study


\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Model A; Factor 1 --> Factor 2; Factor 2 --> Factor 3
library(lavaan)
loading <- matrix(0, 11, 3)
loading[1:3, 1] <- NA
loading[4:7, 2] <- NA
loading[8:11, 3] <- NA
path.A <- matrix(0, 3, 3)
path.A[2, 1] <- NA
path.A[3, 2] <- NA
model.A <- estmodel(LY=loading, BE=path.A, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.A <- analyze(model.A, PoliticalDemocracy)

# Model A; Factor 1 --> Factor 3; Factor 3 --> Factor 2
path.B <- matrix(0, 3, 3)
path.B[3, 1] <- NA
path.B[2, 3] <- NA
model.B <- estmodel(LY=loading, BE=path.B, modelType="SEM", indLab=c(paste("x", 1:3, sep=""), 
	paste("y", 1:8, sep="")))

out.B <- analyze(model.B, PoliticalDemocracy)

loading.mis <- matrix("runif(1, -0.2, 0.2)", 11, 3)
loading.mis[is.na(loading)] <- 0

# Create SimSem object for data generation and data analysis template
datamodel.A <- model.lavaan(out.A, std=TRUE, LY=loading.mis)
datamodel.B <- model.lavaan(out.B, std=TRUE, LY=loading.mis)

# Get sample size
n <- nrow(PoliticalDemocracy)

# The actual number of replications should be greater than 20.
output.A.A <- sim(20, n=n, model.A, generate=datamodel.A) 
output.A.B <- sim(20, n=n, model.B, generate=datamodel.A)
output.B.A <- sim(20, n=n, model.A, generate=datamodel.B)
output.B.B <- sim(20, n=n, model.B, generate=datamodel.B)

# Find the p-value comparing the observed fit indices against the simulated 
# sampling distribution of fit indices

pValueNonNested(out.A, out.B, output.A.A, output.A.B, output.B.A, output.B.B)

# If the p-value for model A is significant but the p-value for model B is not
# significant, model B is preferred.

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{rawDraw}{Draw values from vector or matrix objects}{rawDraw}
%
\begin{Description}\relax
Takes one matrix or vector object (\code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}}) and returns a matrix or a vector with numerical values for population parameters. If a matrix is symmetric, it is arbitrarily chosen that parameters on the upper triangular elements are set equal to the parameters on the lower triangular elements.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rawDraw(simDat, constraint = TRUE, misSpec = TRUE, parMisOnly = FALSE, 
    misOnly = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{simDat}] 
A matrix or vector object (\code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} or \code{\LinkA{SimVector}{SimVector.Rdash.class}})

\item[\code{constraint}] 
If TRUE, then constraints are applied simultaneously

\item[\code{misSpec}] 
If TRUE, then a list is returned with [[1]] parameters with no misspec and [[2]] same parameters + misspec (if any)

\item[\code{parMisOnly}] 
If TRUE, then only the parameters + misspecification is returned

\item[\code{misOnly}] 
If TRUE, then only the misspecification is returned

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix (or vector) or a list of matrices (or vectors) which contains the draw result.
\end{Value}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 7, 3)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[1:7, 3] <- NA
loadingVal <- matrix(0, 7, 3)
loadingVal[1:3, 1] <- "runif(1, 0.5, 0.7)"
loadingVal[4:6, 2] <- "runif(1, 0.5, 0.7)"
loadingVal[1:6, 3] <- "runif(1, 0.3, 0.5)"
loadingVal[7, 3] <- 1
loading.mis <- matrix("runif(1, -0.2, 0.2)", 7, 3)
loading.mis[is.na(loading)] <- 0
loading.mis[,3] <- 0
loading.mis[7,] <- 0
loading[1:3, 1] <- "con1"
LY <- bind(loading, loadingVal, misspec=loading.mis)

# Draw values
rawDraw(LY)

# Draw only model parameters containing misspecification
rawDraw(LY, parMisOnly=TRUE)

# Draw only misspecification.
rawDraw(LY, misOnly=TRUE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{setPopulation}{Set the data generation population model underlying an object}{setPopulation}
%
\begin{Description}\relax
This function will set the data generation population model to be an appropriate one. If the appropriate data generation model is specified, the additional features can be seen in \code{\LinkA{summary}{summary}} or \code{\LinkA{summaryParam}{summaryParam}} functions on the target object, such as bias in parameter estimates or percentage coverage. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setPopulation(target, population)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{target}] 
The result object that you wish to set the data generation population model (\code{linkS4class\{SimResult\}}).

\item[\code{population}] 
The population parameters specified in the \code{linkS4class\{SimSem\}} object

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The target object that is changed the parameter.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for result object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# See each class for an example.
## Not run: 
# Data generation model
loading <- matrix(0, 7, 3)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[1:7, 3] <- NA
loadingVal <- matrix(0, 7, 3)
loadingVal[1:3, 1] <- "runif(1, 0.5, 0.7)"
loadingVal[4:6, 2] <- "runif(1, 0.5, 0.7)"
loadingVal[1:6, 3] <- "runif(1, 0.3, 0.5)"
loadingVal[7, 3] <- 1
loading.mis <- matrix("runif(1, -0.2, 0.2)", 7, 3)
loading.mis[is.na(loading)] <- 0
loading.mis[,3] <- 0
loading.mis[7,] <- 0
LY <- bind(loading, loadingVal, misspec=loading.mis)

RPS <- binds(diag(3))

path <- matrix(0, 3, 3)
path[2, 1] <- NA
BE <- bind(path, "runif(1, 0.3, 0.5)")

RTE <- binds(diag(7))

VY <- bind(c(rep(NA, 6), 0), c(rep(1, 6), ""))

datamodel <- model(LY=LY, RPS=RPS, BE=BE, RTE=RTE, VY=VY, modelType="SEM")

# Data analysis model
loading <- matrix(0, 7, 3)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[7, 3] <- NA
path <- matrix(0, 3, 3)
path[2, 1] <- NA
path[1, 3] <- NA
path[2, 3] <- NA
errorCov <- diag(NA, 7)
errorCov[7, 7] <- 0
facCov <- diag(3)
analysis <- estmodel(LY=loading, BE=path, TE=errorCov, PS=facCov, modelType="SEM", 
	indLab=paste("y", 1:7, sep=""))

# In reality, more than 10 replications are needed.
Output <- sim(10, n=200, analysis, generate=datamodel)

# Population 
loadingVal <- matrix(0, 7, 3)
loadingVal[1:3, 1] <- 0.6
loadingVal[4:6, 2] <- 0.6
loadingVal[7, 3] <- 1
LY <- bind(loading, loadingVal)
pathVal <- matrix(0, 3, 3)
pathVal[2, 1] <- 0.4
pathVal[1, 3] <- 0.4
pathVal[2, 3] <- 0.4
BE <- bind(path, pathVal)
PS <- binds(facCov)
errorCovVal <- diag(0.64, 7)
errorCovVal[7, 7] <- 0
TE <- binds(errorCov, errorCovVal)
population <- model(LY=LY, PS=PS, BE=BE, TE=TE, modelType="SEM")

# Set up the new population
Output <- setPopulation(Output, population) 

# This summary will contain the bias information
summary(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sim}{Run a monte carlo simulation with a structural equation model.}{sim}
%
\begin{Description}\relax
This function can be used to generate data, analyze the generated data, and summarized into a result object where parameter estimates, standard errors, fit indices, and other characteristics of each replications are saved. 
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sim(nRep, model, n, generate = NULL, ..., rawData = NULL, miss = NULL, datafun=NULL, 
	lavaanfun = "lavaan", outfun=NULL, outfundata = NULL, pmMCAR = NULL, 
	pmMAR = NULL, 	facDist = NULL, indDist = NULL, errorDist = NULL, 
	sequential = FALSE, saveLatentVar = FALSE, modelBoot = FALSE, realData = NULL, 
	covData = NULL, maxDraw = 50, misfitType = "f0", misfitBounds = NULL, 
	averageNumMisspec = FALSE, optMisfit=NULL, optDraws = 50, 
	createOrder = c(1, 2, 3), aux = NULL, group = NULL, mxFit = FALSE, 
	mxMixture = FALSE, citype = NULL, cilevel = 0.95, seed = 123321, silent = FALSE, 
	multicore = options('simsem.multicore')[[1]], cluster = FALSE, 
	numProc = NULL, paramOnly = FALSE, dataOnly=FALSE, smartStart=FALSE, 
	previousSim = NULL, completeRep = FALSE, stopOnError = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nRep}] 
Number of replications. If any of the \code{n}, \code{pmMCAR}, or \code{pmMAR} arguments are specified as lists, the number of replications will default to the length of the list(s), and \code{nRep} need not be specified.

\item[\code{model}] 
There are three options for this argument: 1. \code{\LinkA{SimSem}{SimSem.Rdash.class}} object created by \code{\LinkA{model}{model}}, 2. \code{lavaan} script, \code{lavaan} parameter table, or a list that contains all argument that users use to run \code{lavaan} (including \code{cfa}, \code{sem}, \code{lavaan}), 3. \code{MxModel} object from the \code{OpenMx} package, or 4. a function that takes a data set and return a list of \code{coef}, \code{se}, and \code{converged} (see details below). For the \code{\LinkA{SimSem}{SimSem.Rdash.class}} object, if the \code{generate} argument is not specified, then the object in the \code{model} argument will be used for both data generation and analysis. If \code{generate} is specified, then the \code{model} argument will be used for data analysis only. 

\item[\code{n}] 
Sample size. Either a single value, or a list of values to vary sample size across replications. The \code{n} argument can also be specified as a random distribution object; if any resulting values are non-integers, the decimal will be rounded. 

\item[\code{generate}] 
There are three options for this argument: 1. \code{\LinkA{SimSem}{SimSem.Rdash.class}} object created by \code{\LinkA{model}{model}}, 2. \code{lavaan} script, \code{lavaan} parameter table (for data generation; see \code{\LinkA{simulateData}{simulateData}}), or a list that contains all argument that users use to run \code{\LinkA{simulateData}{simulateData}}, 3. \code{MxModel} object with population parameters specified in the starting values of all matrices in the model. This argument cannot be specified the same time as the \code{rawData} argument

\item[\code{rawData}] 
There are two options for this argument: 1. a list of data frames to be used in simulations or 2. a population data. If a list of data frames is specified, the \code{nRep} and \code{n} arguments must not be specified. If a population data frame is specified, the \code{nRep} and \code{n} arguments are required.

\item[\code{miss}] 
A missing data template created using the \code{\LinkA{miss}{miss}} function.

\item[\code{datafun}] 
A function to be applied to each generated data set across replications.

\item[\code{lavaanfun}] 
The character of the function name used in running lavaan model (\code{"cfa"}, \code{"sem"}, \code{"growth"}, \code{"lavaan"}). This argument is required only when lavaan script or a list of arguments is specified in the \code{model} argument.

\item[\code{outfun}] 
A function to be applied to the \code{\LinkA{lavaan}{lavaan.Rdash.class}} output at each replication. Output from this function in each replication will be saved in the simulation output (\code{\LinkA{SimResult}{SimResult.Rdash.class}}), and can be obtained using the \code{\LinkA{getExtraOutput}{getExtraOutput}} function.

\item[\code{outfundata}] 
A function to be applied to the \code{\LinkA{lavaan}{lavaan.Rdash.class}} output and the generated data at each replication. Users can get the characteristics of the generated data and also compare the characteristics with the generated output. The output from this function in each replication will be saved in the simulation output (\code{\LinkA{SimResult}{SimResult.Rdash.class}}), and can be obtained using the \code{\LinkA{getExtraOutput}{getExtraOutput}} function.

\item[\code{pmMCAR}] 
The percentage of data completely missing at random (0 <= pmMCAR < 1). Either a single value or a vector of values in order to vary pmMCAR across replications (with length equal to nRep or a divisor of nRep). The \code{objMissing} argument is only required when specifying complex missing value data generation, or when using multiple imputation. 

\item[\code{pmMAR}] 
The percentage of data missing at random (0 <= pmCAR < 1). Either a single value or a vector of values in order to vary pmCAR across replications (with length equal to nRep or a divisor of nRep). The \code{objMissing} argument is only required when specifying complex missing value data generation, or when using multiple imputation. 


\item[\code{facDist}]  
Factor distributions. Either a list of \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} objects or a single \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object to give all factors the same distribution. Use when \code{sequential} is \code{TRUE}.

\item[\code{indDist}]  
Indicator distributions. Either a list of \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} objects or a single \code{\LinkA{SimDataDist}{SimDataDist.Rdash.class}} object to give all indicators the same distribution. Use when \code{sequential} is \code{FALSE}.

\item[\code{errorDist}]  
An object or list of objects of type \code{SimDataDist} indicating the distribution of errors. If a single \code{SimDataDist} is specified, each error will be genrated with that distribution.

\item[\code{sequential}]  
If \code{TRUE}, a sequential method is used to generate data in which factor data is generated first, and is subsequently applied to a set of equations to obtain the indicator data. If \code{FALSE}, data is generated directly from model-implied mean and covariance of the indicators.

\item[\code{saveLatentVar}]  
If \code{TRUE}, the generated latent variable scores and measurement error scores are also provided as the attribute of the generated data. Users can use the \code{outfundata} to compare the latent variable scores with the estimated output. The \code{sequential} argument must be \code{TRUE} in order to use this option.

\item[\code{modelBoot}]  
When specified, a model-based bootstrap is used for data generation (for use with the \code{realData} argument). See \code{\LinkA{draw}{draw}} for further information.

\item[\code{realData}]  
A data.frame containing real data. Generated data will follow the distribution of this data set.

\item[\code{covData}]  
A data.frame containing covariate data, which can have any distributions. This argument is required when users specify \code{GA} or \code{KA} matrices in the model template (\code{\LinkA{SimSem}{SimSem.Rdash.class}}).

\item[\code{maxDraw}]  
The maximum number of attempts to draw a valid set of parameters (no negative error variance, standardized coefficients over 1).

\item[\code{misfitType}]  
Character vector indicating the fit measure used to assess the misfit of a set of parameters. Can be "f0", "rmsea", "srmr", or "all". 

\item[\code{misfitBounds}]  
Vector that contains upper and lower bounds of the misfit measure. Sets of parameters drawn that are not within these bounds are rejected.

\item[\code{averageNumMisspec}]  
If \code{TRUE}, the provided fit will be divided by the number of misspecified parameters. 

\item[\code{optMisfit}]  
Character vector of either "min" or "max" indicating either maximum or minimum optimized misfit. If not null, the set of parameters out of the number of draws in "optDraws" that has either the maximum or minimum misfit of the given misfit type will be returned.

\item[\code{optDraws}]  
Number of parameter sets to draw if optMisfit is not null. The set of parameters with the maximum or minimum misfit will be returned.

\item[\code{createOrder}] 
The order of 1) applying equality/inequality constraints, 2) applying misspecification, and 3) fill unspecified parameters (e.g., residual variances when total variances are specified). The specification of this argument is a vector of different orders of 1 (constraint), 2 (misspecification), and 3 (filling parameters). For example, \code{c(1, 2, 3)} is to apply constraints first, then add the misspecification, and finally fill all parameters. See the example of how to use it in the \code{\LinkA{draw}{draw}} function.

\item[\code{aux}] 
The names of auxiliary variables saved in a vector.

\item[\code{group}] 
The name of the group variable. This argument is used when \code{lavaan} script or \code{MxModel} is used in the \code{model} only.

\item[\code{mxFit}] 
A logical whether to find an extensive list of fit measures (which will be slower). This argument is applicable when \code{MxModel} is used in the \code{model} argument only.

\item[\code{mxMixture}] 
A logical whether to the analysis model is a mixture model. This argument is applicable when \code{MxModel} is used in the \code{model} argument only.

\item[\code{citype}] 
Type of confidence interval. For the current version, this argument will be forwarded to the \code{"boot.ci.type"} argument in the  \code{\LinkA{parameterEstimates}{parameterEstimates}} function from the \code{lavaan} package. This argument is not active when the \code{OpenMx} package is used.

\item[\code{cilevel}] 
Confidence level. For the current version, this argument will be forwarded to the \code{"level"} argument in the  \code{\LinkA{parameterEstimates}{parameterEstimates}} function from the \code{lavaan} package. This argument is not active when the \code{OpenMx} package is used.

\item[\code{seed}]  
Random number seed. Reproducibility across multiple cores or clusters is ensured using R'Lecuyer package.

\item[\code{silent}]  
If \code{TRUE}, suppress warnings.

\item[\code{multicore}]  
Users may put \code{TRUE} or \code{FALSE}. If \code{TRUE}, multiple processors within a computer will be utilized. The default value is \code{FALSE}. Users may permanently change the default value by assigning the following line: \code{options('simsem.multicore' = TRUE)}

\item[\code{cluster}]  
Not applicable now. Used to specify nodes in hpc in order to be parallelizable.

\item[\code{numProc}]  
Number of processors for using multiple processors. If it is \code{NULL}, the package will find the maximum number of processors.

\item[\code{paramOnly}]  
If \code{TRUE}, only the parameters from each replication will be returned.

\item[\code{dataOnly}]  
If \code{TRUE}, only the raw data generated from each replication will be returned.

\item[\code{smartStart}] 
Defaults to FALSE. If TRUE, population parameter values that are real numbers will be used as starting values. When tested in small models, the time elapsed when using population values as starting values was greater than the time reduced during analysis, and convergence rates were not affected. 

\item[\code{previousSim}] 
A result object that users wish to add the results of the current simulation in

\item[\code{completeRep}] 
If \code{TRUE}, the function will run until the number of convergent replication equal to the specified \code{nRep}.

\item[\code{stopOnError}]  
If \code{TRUE}, stop running the simulation when the error occurs during the data analysis on any replications.

\item[\code{...}]  
Additional arguments to be passed to lavaan.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is executed as follows: 1. parameters are drawn from the specified data-generation model (applicable only simsem model template, \code{\LinkA{SimSem}{SimSem.Rdash.class}}, only), 2. the drawn (or the specified) parameters are used to create data, 3. data can be transformed using the \code{datafun} argument, 4. specified missingness (if any) is imposed, 5. data are analyzed using the specified analysis model, 6. parameter estimates, standard errors, fit indices, and other characteristics of a replication are extracted, 7. additional outputs (if any) are extracted using the \code{outfun} argument, and 8. results across replications are summarized in a result object, \code{\LinkA{SimResult}{SimResult.Rdash.class}}).

There are five ways to provide or generate data in this function: 
\begin{enumerate}

\item \code{\LinkA{SimSem}{SimSem.Rdash.class}} can be used as a template to generate data, which can be created by the \code{\LinkA{model}{model}} function. The \code{\LinkA{SimSem}{SimSem.Rdash.class}} can be specified in the \code{generate} argument.
\item \code{lavaan} script, parameter table for the \code{lavaan} package, or a list of arguments for the \code{\LinkA{simulateData}{simulateData}} function. The \code{lavaan} script can be specified in the \code{generate} argument.
\item \code{MxModel} object from the \code{OpenMx} package. The \code{MxModel} object can be specified in the \code{generate} argument.
\item A list of raw data for each replication can be provided for the \code{rawData} argument. The \code{sim} function will analyze each data and summarize the result. Note that the \code{generate}, \code{n} and \code{nRep} could not be specified if the list of raw data is provided.
\item Population data can be provided for the \code{rawData} argument. The \code{sim} function will randomly draw sample data sets and analyze data. Note that the \code{n} and \code{nRep} must be specified if the population data are provided. The \code{generate} argument must not be specified.

\end{enumerate}


Note that all generated or provided data can be transformed based on Bollen-Stine approach by providing a real data in the \code{realData} argument if any of the first three methods are used.

There are four ways to analyze the data sets for each replication by setting the \code{model} argument as
\begin{enumerate}

\item \code{\LinkA{SimSem}{SimSem.Rdash.class}} can be used as a template for data analysis. 
\item \code{lavaan} script, parameter table for the \code{lavaan} package, or a list of arguments for the \code{\LinkA{lavaan}{lavaan}}, \code{\LinkA{sem}{sem}}, \code{\LinkA{cfa}{cfa}}, or \code{\LinkA{growth}{growth}} function. Note that if the desired function to analyze data can be specified in the \code{lavaanfun} argument, which the default is the \code{\LinkA{lavaan}{lavaan}} function
\item \code{MxModel} object from the \code{OpenMx} package. The object does not need to have data inside. Note that if users need an extensive fit indices, the \code{mxFit} argument should be specified as \code{TRUE}. If users wish to analyze by mixture model, the \code{mxMixture} argument should be \code{TRUE} such that the \code{sim} function knows how to handle the data.
\item A function that takes a data set and returns a list. The list must contain at least three objects: a vector of parameter estimates (\code{coef}), a vector of standard error (\code{se}), and the convergence status as \code{TRUE} or \code{FALSE} (\code{converged}). There are seven optional objects in the list: a vector of fit indices (\code{fit}), a vector of standardized estimates (\code{std}), any extra output (\code{extra}), fraction missing type I (\code{FMI1}), fraction missing type II (\code{FMI2}), lower bounds of confidence intervals (\code{cilower}), and upper bounds of confidence intervals (\code{ciupper}). Note that the \code{coef}, \code{se}, \code{std}, \code{FMI1}, \code{FMI2}, \code{cilower}, and \code{ciupper} must be a vector with names. The name of those vectors across different objects must be the same.

\end{enumerate}


Any combination of data-generation methods and data-analysis methods are valid. For example, data can be simulated using lavaan script and analyzed by \code{MxModel}.  Paralleled processing can be enabled using the \code{multicore} argument. 
\end{Details}
%
\begin{Value}
A result object (\code{\LinkA{SimResult}{SimResult.Rdash.class}})
\end{Value}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu})
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for the resulting output description

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Please go to www.simsem.org for more examples.

# Example of using simsem model template

loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model, n=200)
summary(Output)

# Example of using simsem model template

popModel <- "
f1 =~ 0.7*y1 + 0.7*y2 + 0.7*y3
f2 =~ 0.7*y4 + 0.7*y5 + 0.7*y6
f1 ~~ 1*f1
f2 ~~ 1*f2
f1 ~~ 0.5*f2
y1 ~~ 0.49*y1
y2 ~~ 0.49*y2
y3 ~~ 0.49*y3
y4 ~~ 0.49*y4
y5 ~~ 0.49*y5
y6 ~~ 0.49*y6
"

analysisModel <- "
f1 =~ y1 + y2 + y3
f2 =~ y4 + y5 + y6
"

Output <- sim(5, model=analysisModel, n=200, generate=popModel, std.lv=TRUE, lavaanfun = "cfa")
summary(Output)

# Example of using population data

pop <- data.frame(y1 = rnorm(100000, 0, 1), y2 = rnorm(100000, 0, 1))

covModel <- "
y1 ~~ y2
"

Output <- sim(5, model=covModel, n=200, rawData=pop, lavaanfun = "cfa")
summary(Output)

# Example of data transformation: Transforming to standard score
fun1 <- function(data) {
	temp <- scale(data)
	as.data.frame(temp)
}

# Example of additional output: Extract modification indices from lavaan
fun2 <- function(out) {
	inspect(out, "mi")
}

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model,n=200,datafun=fun1, outfun=fun2)
summary(Output)

# Get modification indices
getExtraOutput(Output)

# Example of additional output: Comparing latent variable correlation

outfundata <- function(out, data) {
	predictcor <- inspect(out, "coef")$psi[2, 1]
	latentvar <- attr(data, "latentVar")[,c("f1", "f2")]
	latentcor <- cor(latentvar)[2,1]
	latentcor - predictcor
}

Output <- sim(5, CFA.Model,n=200, sequential = TRUE, saveLatentVar = TRUE, 
	outfundata = outfundata)
	
getExtraOutput(Output)

# Example of analyze using a function

analyzeFUN <- function(data) {
	out <- lm(y2 ~ y1, data=data)
	coef <- coef(out)
	se <- sqrt(diag(vcov(out)))
	fit <- c(loglik = as.numeric(logLik(out)))
	converged <- TRUE # Assume to be convergent all the time
	return(list(coef = coef, se = se, fit = fit, converged = converged))
}

Output <- sim(5, model=analyzeFUN, n=200, rawData=pop, lavaanfun = "cfa")
summary(Output)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimDataDist-class}{Class \code{"SimDataDist"}: Data distribution object}{SimDataDist.Rdash.class}
\aliasA{plotDist,SimDataDist-method}{SimDataDist-class}{plotDist,SimDataDist.Rdash.method}
\aliasA{summary,SimDataDist-method}{SimDataDist-class}{summary,SimDataDist.Rdash.method}
\keyword{classes}{SimDataDist-class}
%
\begin{Description}\relax
This class will provide the distribution of a dataset.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by \code{\LinkA{bindDist}{bindDist}} function. It can also be called from the form \code{new("SimDataDist", ...)}.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{p}:] Number of variables
\item[\code{margins}:] A character vector specifying all the marginal distributions
\item[\code{paramMargins}:] A list whose each component is a list of named components, giving the parameter values of the marginal distributions.
\item[\code{keepScale}:] Transform back to retain the mean and standard deviation of a variable equal to the model implied mean and standard deviation (with sampling error)
\item[\code{reverse}:] To mirror each variable or not. If \code{TRUE}, reverse the distribution of a variable (e.g., from positive skewed to negative skewed).
\item[\code{copula}:] The multivariate copula template for data generation. See \code{\LinkA{bindDist}{bindDist}}
\item[\code{skewness}:] The target skewness values of each variable
\item[\code{kurtosis}:] The target (excessive) kurtosis values of each variable

\end{description}

\end{Section}
%
\begin{Section}{Methods}
\begin{itemize}

\item summaryTo summarize the object
\item plotDistTo plot a density distribution (for one variable) or a contour plot (for two variables).

\end{itemize}

\end{Section}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{bindDist}{bindDist}} The constructor of this class.	

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimDataDist")

d1 <- list(df=2)
d2 <- list(df=3)
d3 <- list(df=4)
d4 <- list(df=5)
d5 <- list(df=3)
d6 <- list(df=4)
d7 <- list(df=5)
d8 <- list(df=6)

dist <- bindDist(c(rep("t", 4), rep("chisq", 8)), d1, d2, d3, d4, d5, d6, d7, d8, d5, d6, d7, d8)
summary(dist)

dist2 <- bindDist(skewness = seq(-3, 3, length.out=12), kurtosis = seq(2, 5, length.out=12))
summary(dist2)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimMatrix-class}{Matrix object: Random parameters matrix}{SimMatrix.Rdash.class}
\aliasA{summary,SimMatrix-method}{SimMatrix-class}{summary,SimMatrix.Rdash.method}
\aliasA{summaryShort,SimMatrix-method}{SimMatrix-class}{summaryShort,SimMatrix.Rdash.method}
\keyword{classes}{SimMatrix-class}
%
\begin{Description}\relax
This object can be used to represent a matrix in SEM model. It contains free parameters, fixed values, starting values, and model misspecification. This object can be represented mean, intercept, or variance vectors.
\end{Description}
%
\begin{Section}{Objects from the Class}
This object is created by \code{\LinkA{bind}{bind}} or \code{\LinkA{binds}{binds}} function. 
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{free}:]  The free-parameter vector. Any NA elements or character elements are free. Any numeric elements are fixed as the specified number. If any free elements have the same characters (except NA), the elements are equally constrained. 
\item[\code{popParam}:]  Real population parameters of the free elements. 
\item[\code{misspec}:]  Model misspecification that will be added on top of the fixed and real parameters. 
\item[\code{symmetric}:]  If TRUE, the specified matrix is symmetric. 


\end{description}

\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{\LinkA{rawDraw}{rawDraw}}] Draws data-generation parameters.
\item[\code{\LinkA{summaryShort}{summaryShort}}] Provides a short summary of all information in the object 
\item[\code{summary}] Provides a thorough description of all information in the object 

\end{description}

\end{Section}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimVector}{SimVector.Rdash.class}} for random parameter vector.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimMatrix")

loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
summary(LY)
rawDraw(LY)

LY <- bind(loading, "rnorm(1, 0.6, 0.05)")
summary(LY)
rawDraw(LY)

mis <- matrix("runif(1, -0.1, 0.1)", 6, 2)
mis[is.na(loading)] <- 0
LY <- bind(loading, "rnorm(1, 0.6, 0.05)", mis)
summary(LY)
rawDraw(LY)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimMissing-class}{Class \code{"SimMissing"}}{SimMissing.Rdash.class}
\aliasA{summary,SimMissing-method}{SimMissing-class}{summary,SimMissing.Rdash.method}
\keyword{classes}{SimMissing-class}
%
\begin{Description}\relax
Missing information imposing on the complete dataset
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by \code{\LinkA{miss}{miss}} function. 
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{cov}:] Column indices of any normally distributed covariates used in the data set.
\item[\code{pmMCAR}:] Decimal percent of missingness to introduce completely at random on all variables.
\item[\code{pmMAR}:] Decimal percent of missingness to introduce using the listed covariates as predictors.
\item[\code{logit}:] The script used for imposing missing values by logistic regression. See \code{\LinkA{miss}{miss}} for further details.
\item[\code{nforms}:] The number of forms for planned missing data designs, not including the shared form.
\item[\code{itemGroups}:] List of lists of item groupings for planned missing data forms. Without this, items will be divided into groups sequentially (e.g. 1-3,4-6,7-9,10-12)
\item[\code{twoMethod}:] Vector of (percent missing, column index). Will put a given percent
missing on that column in the matrix to simulate a two method
planned missing data research design. 
\item[\code{prAttr}:] Probability (or vector of probabilities) of an entire case being removed due to attrition at a given time point. See \code{\LinkA{imposeMissing}{imposeMissing}} for further details.
\item[\code{m}:] The number of imputations. The default is 0 such that the full information maximum likelihood is used.
\item[\code{chi}:] The chi-square pooling method. See \code{\LinkA{runMI}{runMI}} function for further details.
\item[\code{package}:] The package to be used in multiple imputation. The default value of this function is \code{"default"}. For the default option, if \code{m} is 0, the full information maximum likelihood is used. If \code{m} is greater than 0, the Amelia package is used.
\item[\code{convergentCutoff}:] If the proportion of convergent results across imputations are greater than the specified value (the default is 80\%), the analysis on the dataset is considered as convergent. Otherwise, the analysis is considered as nonconvergent. This attribute is applied for multiple imputation only.
\item[\code{timePoints}:] Number of timepoints items were measured over. For longitudinal data, planned missing designs will be implemented within each timepoint.
\item[\code{ignoreCols}:] The columns not imposed any missing values for any missing data patterns
\item[\code{threshold}:] The threshold of covariates that divide between the area to impose missing and the area not to impose missing. The default threshold is the mean of the covariate.
\item[\code{covAsAux}:] If \code{TRUE}, the covariate listed in the object will be used as auxiliary variables when putting in the model object. If \code{FALSE}, the covariate will be included in the analysis.
\item[\code{logical}:] A matrix of logical values (\code{TRUE/FALSE}). If a value in the dataset is corresponding to the \code{TRUE} in the logical matrix, the value will be missing.
\item[\code{args}:] A list of additional options to be passed to the multiple impuatation function in each package.

\end{description}
  
\end{Section}
%
\begin{Section}{Methods}
\begin{itemize}

\item \code{\LinkA{summary}{summary}} To summarize the object
\item \code{\LinkA{impose}{impose}} To impose missing information into data

\end{itemize}

\end{Section}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu})
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})  
Kyle Lang (University of Kansas; \email{kylelang@ku.edu})
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{imposeMissing}{imposeMissing}} for directly imposing missingness into a dataset.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
misstemplate <- miss(pmMCAR=0.2)
summary(misstemplate)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimResult-class}{Class \code{"SimResult"}: Simulation Result Object}{SimResult.Rdash.class}
\aliasA{summary,SimResult-method}{SimResult-class}{summary,SimResult.Rdash.method}
\aliasA{summaryShort,SimResult-method}{SimResult-class}{summaryShort,SimResult.Rdash.method}
\keyword{classes}{SimResult-class}
%
\begin{Description}\relax
This class will save data analysis results from multiple replications, such as fit indices cutoffs or power, parameter values, model misspecification, etc.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by \code{\LinkA{sim}{sim}}. 
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{modelType}:] Analysis model type (CFA, Path, or SEM) 
\item[\code{nRep}:] Number of replications have been created and run simulated data. 
\item[\code{coef}:] Parameter estimates from each replication
\item[\code{se}:] Standard errors of parameter estimates from each replication
\item[\code{fit}:] Fit Indices values from each replication
\item[\code{converged}:] The convergence status of each replication: 0 = convergent, 1 = not convergent, 2 = nonconvergent in multiple imputed results, 3 = improper solutions for SE (less than 0 or NA), 4 = improper solution for variance (less than 0), 5 = improper solution for correlation (greater than 1 or less than -1) 
\item[\code{seed}:] Seed number. 
\item[\code{paramValue}:] Population model underlying each simulated dataset.
\item[\code{paramOnly}:] If \code{TRUE}, the result object saves only population characteristics and do not save sample characteristics (e.g., parameter estimates and standard errors.
\item[\code{misspecValue}:] Misspecified-parameter values that are imposed on the population model in each replication.
\item[\code{popFit}:] The amount of population misfit. See details at \code{\LinkA{summaryMisspec}{summaryMisspec}}
\item[\code{FMI1}:] Fraction Missing Method 1.
\item[\code{FMI2}:] Fraction Missing Method 2.
\item[\code{cilower}:] Lower bounds of confidence interval.
\item[\code{ciupper}:] Upper bounds of confidence interval.
\item[\code{stdCoef}:] Standardized coefficients from each replication
\item[\code{n}:] The total sample size of the analyzed data.
\item[\code{nobs}:] The sample size within each group.
\item[\code{pmMCAR}:] Percent missing completely at random.
\item[\code{pmMAR}:] Percent missing at random.
\item[\code{extraOut}:] Extra outputs obtained from running the function specified in \code{outfun} argument in the \code{\LinkA{sim}{sim}} function.
\item[\code{timing}:] Time elapsed in each phase of the simulation.

\end{description}

\end{Section}
%
\begin{Section}{Methods}
The following methods are listed alphabetically. More details can be found by following the link of each method.
\begin{itemize}

\item \code{\LinkA{anova}{anova,SimResult.Rdash.method}} to find the averages of model fit statistics and indices for nested models, as well as the differences of model fit indices among models. This function requires at least two \code{SimResult} objects. 
\item \code{\LinkA{coef}{coef,SimResult.Rdash.method}} to extract parameter estimates of each replication
\item \code{\LinkA{findCoverage}{findCoverage}} to find a value of independent variables (e.g., sample size) that provides a given value of coverage rate.
\item \code{\LinkA{findPower}{findPower}} to find a value of independent variables (e.g., sample size) that provides a given value of power of a parameter estimate. 
\item \code{\LinkA{getCoverage}{getCoverage}} to get the coverage rate of the confidence interval of each parameter estimate
\item \code{\LinkA{getCIwidth}{getCIwidth}} to get a median or percentile rank (assurance) of confidence interval widths of parameters estimates
\item \code{\LinkA{getCutoff}{getCutoff}} to get the cutoff of fit indices based on a priori alpha level.
\item \code{\LinkA{getCutoffNested}{getCutoffNested}} to get the cutoff of the difference in fit indices of nested models based on a priori alpha level. 
\item \code{\LinkA{getCutoffNonNested}{getCutoffNonNested}} to get the cutoff of the difference in fit indices of nonnested models based on a priori alpha level. 
\item \code{\LinkA{getExtraOutput}{getExtraOutput}} to get extra outputs that users requested before running a simulation
\item \code{\LinkA{getPopulation}{getPopulation}} to get population parameter values underlying each dataset
\item \code{\LinkA{getPower}{getPower}} to get the power of each parameter estimate
\item \code{\LinkA{getPowerFit}{getPowerFit}} to get the power in rejecting alternative models based on absolute model fit cutoff. 
\item \code{\LinkA{getPowerFitNested}{getPowerFitNested}} to get the power in rejecting alternative models based on the difference between model fit cutoffs of nested models. 
\item \code{\LinkA{getPowerFitNonNested}{getPowerFitNonNested}} to get the power in rejecting alternative models based on the difference between model fit cutoffs of nonnested models.  
\item \code{\LinkA{inspect}{inspect,SimResult.Rdash.method}} Extract target information from the simulation result. The available information is listed in this \code{\LinkA{link}{inspect,SimResult.Rdash.method}}
\item \code{\LinkA{likRatioFit}{likRatioFit}} to find the likelihood ratio (or Bayes factor) based on the bivariate distribution of fit indices
\item \code{\LinkA{plotCoverage}{plotCoverage}} to plot the coverage rate of confidence interval of parameter estimates
\item \code{\LinkA{plotCIwidth}{plotCIwidth}} to plot confidence interval widths with a line of a median or percentile rank (assurance) 
\item \code{\LinkA{plotCutoff}{plotCutoff}} to plot sampling distributions of fit indices with an option to draw fit indices cutoffs by specifying a priori alpha level.
\item \code{\LinkA{plotCutoffNested}{plotCutoffNested}} to plot sampling distributions of the difference in fit indices between nested models with an option to draw fit indices cutoffs by specifying a priori alpha level.
\item \code{\LinkA{plotCutoffNonNested}{plotCutoffNonNested}} to plot sampling distributions of the difference in fit indices between nonnested models with an option to draw fit indices cutoffs by specifying a priori alpha level.
\item \code{\LinkA{plotMisfit}{plotMisfit}} to visualize the population misfit and misspecified parameter values
\item \code{\LinkA{plotPower}{plotPower}} to plot power of parameter estimates 
\item \code{\LinkA{plotPowerFit}{plotPowerFit}} to plot the power in rejecting alternative models based on absolute model fit cutoff.
\item \code{\LinkA{plotPowerFitNested}{plotPowerFitNested}} to plot the power in rejecting alternative models based on the difference between model fit cutoffs of nested models. 
\item \code{\LinkA{plotPowerFitNonNested}{plotPowerFitNonNested}} to plot the power in rejecting alternative models based on the difference between model fit cutoffs of nonnested models.   
\item \code{\LinkA{pValue}{pValue}} to find a p-value in comparing sample fit indices with the null sampling distribution of fit indices
\item \code{\LinkA{pValueNested}{pValueNested}} to find a p-value in comparing the difference in sample fit indices between nested models with the null sampling distribution of the difference in fit indices
\item \code{\LinkA{pValueNonNested}{pValueNonNested}} to find a p-value in comparing the difference in sample fit indices between nonnested models with the null sampling distribution of the difference in fit indices
\item \code{\LinkA{setPopulation}{setPopulation}} to set population model for computing bias
\item \code{\LinkA{summary}{summary}} to summarize the result output
\item \code{\LinkA{summaryConverge}{summaryConverge}} to provide a head-to-head comparison between the characteristics of convergent and nonconvergent replications
\item \code{\LinkA{summaryMisspec}{summaryMisspec}} to provide a summary of model misfit
\item \code{\LinkA{summaryParam}{summaryParam}} to summarize all parameter estimates
\item \code{\LinkA{summaryPopulation}{summaryPopulation}} to summarize the data generation population underlying the simulation study.
\item \code{\LinkA{summarySeed}{summarySeed}} to provide a summary of the seed number in the simulation
\item \code{\LinkA{summaryShort}{summaryShort}} to provide a short summary of the result output
\item \code{\LinkA{summaryTime}{summaryTime}} to provide a summary of time elapsed in the simulation

\end{itemize}

\end{Section}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{sim}{sim}} for the constructor of this class

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimResult")
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=500, CFA.Model)

# Summary the simulation result
summary(Output)

# Short summary of the simulation result
summaryShort(Output)

# Find the fit index cutoff
getCutoff(Output, 0.05)

# Summary of parameter estimates
summaryParam(Output)

# Summary of population parameters
summaryPopulation(Output)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimSem-class}{Class \code{"SimSem"}}{SimSem.Rdash.class}
\aliasA{summary,SimSem-method}{SimSem-class}{summary,SimSem.Rdash.method}
%
\begin{Description}\relax
The template containing data-generation and data-analysis specification
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by \code{\LinkA{model}{model}}. 
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{pt}:]  Parameter table used in data analysis 
\item[\code{dgen}:]  Data generation template 
\item[\code{modelType}:]  Type of models (CFA, Path, or SEM) contained in this object 
\item[\code{groupLab}:]  The label of grouping variable 
\item[\code{con}:]  The list of defined parameters, equality constraints, or inequality constraints specified in the model 

\end{description}

\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[summary] Get the summary of model specification 

\end{description}

\end{Section}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu}), 
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item Create an object this class by CFA, Path Analysis, or SEM model by \code{\LinkA{model}{model}}.

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimSem")

loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
loadingValues[1:3, 1] <- 0.7
loadingValues[4:6, 2] <- 0.7
LY <- bind(loading, loadingValues)
summary(LY)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

# Error Correlation Object
error.cor <- matrix(0, 6, 6)
diag(error.cor) <- 1
RTE <- binds(error.cor)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")
summary(CFA.Model)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{SimVector-class}{Vector object: Random parameters vector}{SimVector.Rdash.class}
\aliasA{summary,SimVector-method}{SimVector-class}{summary,SimVector.Rdash.method}
\aliasA{summaryShort,SimVector-method}{SimVector-class}{summaryShort,SimVector.Rdash.method}
\keyword{classes}{SimVector-class}
%
\begin{Description}\relax
This object can be used to represent a vector in SEM model. It contains free parameters, fixed values, starting values, and model misspecification. This object can be represented mean, intercept, or variance vectors.
\end{Description}
%
\begin{Section}{Objects from the Class}
This object is created by \code{\LinkA{bind}{bind}} function. 
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{free}:] The free-parameter vector. Any NA elements or character elements are free. Any numeric elements are fixed as the specified number. If any free elements have the same characters (except NA), the elements are equally constrained.
\item[\code{popParam}:] Real population parameters of the free elements.
\item[\code{misspec}:] Model misspecification that will be added on top of the fixed and real parameters.

\end{description}

\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{\LinkA{rawDraw}{rawDraw}}] Draws data-generation parameters.
\item[\code{\LinkA{summaryShort}{summaryShort}}] Provides a short summary of all information in the object 
\item[\code{\LinkA{summary}{summary}}] Provides a thorough description of all information in the object 


\end{description}

\end{Section}
%
\begin{Author}\relax
Patrick Miller (Univeristy of Notre Dame; \email{pmille13@nd.edu})
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}} for random parameter matrix 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimVector")

factor.mean <- rep(NA, 2)
factor.mean.starting <- c(5, 2)
AL <- bind(factor.mean, factor.mean.starting)
rawDraw(AL)
summary(AL)
summaryShort(AL)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryConverge}{Provide a comparison between the characteristics of convergent replications and nonconvergent replications}{summaryConverge}
%
\begin{Description}\relax
This function provides a comparison between the characteristics of convergent replications and nonconvergent replications. The comparison includes sample size (if varying), percent missing completely at random (if varying), percent missing at random (if varying), parameter values, misspecified-parameter values (if applicable), and population misfit (if applicable).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryConverge(object, improper = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described

\item[\code{improper}] 
If TRUE, include the replications that provided improper solutions

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list with the following elements:
\begin{itemize}

\item \code{Converged} The number of convergent and nonconvergent replications
\item \code{n} Sample size
\item \code{pmMCAR} Percent missing completely at random
\item \code{pmMAR} Percent missing at random
\item \code{paramValue} Parameter values
\item \code{misspecValue} Misspecified-parameter values
\item \code{popFit} Population misfit. See details of each element at \code{\LinkA{summaryMisspec}{summaryMisspec}}.

\end{itemize}

Each element will provide the head-to-head comparison between convergent and nonconvergent replications properties.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
path.BE <- matrix(0, 4, 4)
path.BE[3, 1:2] <- NA
path.BE[4, 3] <- NA
starting.BE <- matrix("", 4, 4)
starting.BE[3, 1:2] <- "runif(1, 0.3, 0.5)"
starting.BE[4, 3] <- "runif(1, 0.5, 0.7)"
mis.path.BE <- matrix(0, 4, 4)
mis.path.BE[4, 1:2] <- "runif(1, -0.1, 0.1)"
BE <- bind(path.BE, starting.BE, misspec=mis.path.BE)

residual.error <- diag(4)
residual.error[1,2] <- residual.error[2,1] <- NA
RPS <- binds(residual.error, "rnorm(1, 0.3, 0.1)")

loading <- matrix(0, 12, 4)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loading[7:9, 3] <- NA
loading[10:12, 4] <- NA
mis.loading <- matrix("runif(1, -0.3, 0.3)", 12, 4)
mis.loading[is.na(loading)] <- 0
LY <- bind(loading, "runif(1, 0.7, 0.9)", misspec=mis.loading)

mis.error.cor <- matrix("rnorm(1, 0, 0.1)", 12, 12)
diag(mis.error.cor) <- 0
RTE <- binds(diag(12), misspec=mis.error.cor)

SEM.Model <- model(RPS = RPS, BE = BE, LY=LY, RTE=RTE, modelType="SEM")

n1 <- list(mean = 0, sd = 0.1)
chi5 <- list(df = 5)

facDist <- bindDist(c("chisq", "chisq", "norm", "norm"), chi5, chi5, n1, n1)

# In reality, more than 50 replications are needed.
simOut <- sim(50, n=500, SEM.Model, sequential=TRUE, facDist=facDist, estimator="mlr")

# Summary the convergent and nonconvergent replications
summaryConverge(simOut)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryFit}{Provide summary of model fit across replications}{summaryFit}
%
\begin{Description}\relax
This function will provide fit index cutoffs for values of alpha, and mean fit index values across all replications.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryFit(object, alpha = NULL, improper = FALSE, usedFit = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} to be summarized

\item[\code{alpha}] 
The alpha level used to find the fit indices cutoff. If there is no varying condition, a vector of different alpha levels can be provided.

\item[\code{improper}] 
If TRUE, include the replications that provided improper solutions

\item[\code{usedFit}] 
Vector of names of fit indices that researchers wish to summarize. 

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame that provides fit statistics cutoffs and means

When \code{linkS4class\{SimResult\}} has fixed simulation parameters the first colmns are fit index cutoffs for values of alpha and the last column is the mean fit across all replications. Rows are
\begin{itemize}

\item Chi Chi-square fit statistic
\item AIC Akaike Information Criterion
\item BIC Baysian Information Criterion
\item RMSEA Root Mean Square Error of Approximation
\item CFI Comparative Fit Index
\item TLI Tucker-Lewis Index
\item SRMR Standardized Root Mean Residual

\end{itemize}

When \code{linkS4class\{SimResult\}} has random simulation parameters (sample size or percent missing), columns are the fit indices listed above and rows are values of the random parameter.
\end{Value}
%
\begin{Author}\relax
Alexander M. Schoemann (University of Kansas; \email{schoemann@ku.edu})
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the result object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=500, CFA.Model)

# Summarize the sample fit indices
summaryFit(Output)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryMisspec}{Provide summary of the population misfit and misspecified-parameter values across replications}{summaryMisspec}
%
\begin{Description}\relax
This function provides the summary of the population misfit and misspecified-parameter values across replications. The summary will be summarized for the convergent replications only.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryMisspec(object, improper = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described

\item[\code{improper}] 
If TRUE, include the replications that provided improper solutions

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame that provides the summary of population misfit and misspecified-parameter values imposed on the real parameters.

The discrepancy value (\eqn{f_0}{}; Browne \& Cudeck, 1992) is calculated by

\deqn{ F_0 = tr\left( \tilde{\Sigma} \Sigma^{-1} \right) - \log{\left| \tilde{\Sigma} \Sigma^{-1} \right|} - p + \left( \tilde{\mu} - \mu \right)^{\prime} \Sigma^{-1} \left( \tilde{\mu} - \mu \right).	}{}

where \eqn{\mu}{} is the model-implied mean from the real parameters, \eqn{\Sigma}{} is the model-implied covariance matrix from the real parameters, \eqn{\tilde{\mu}}{} is the model-implied mean from the real and misspecified parameters, \eqn{\tilde{\Sigma}}{} is the model-implied covariance matrix from the real and misspecified parameter, \emph{p} is the number of indicators. For the multiple groups, the resulting \eqn{f_0}{} value is the sum of this value across groups.

The root mean squared error of approximation (rmsea) is calculated by

\deqn{rmsea = \sqrt{\frac{f_0}{df}}}{}

where \eqn{df}{} is the degree of freedom in the real model.

The standardized root mean squared residual (srmr) can be calculated by

\deqn{srmr = \sqrt{\frac{2\sum_{g} \sum_{i} \sum_{j \le i} \left( \frac{s_{gij}}{\sqrt{s_{gii}}\sqrt{s_{gjj}}} - \frac{\hat{\sigma}_{gij}}{\sqrt{\hat{\sigma}_{gii}}\sqrt{\hat{\sigma}_{gjj}}} \right)}{g \times p(p + 1)}}}{}

where \eqn{s_{gij}}{} is the observed covariance between indicators \emph{i} and \emph{j} in group \emph{g}, \eqn{\hat{\sigma}_{ij}}{} is the model-implied covariance between indicators \emph{i} and \emph{j} in group \emph{g}, \emph{p} is the number of indicators.

\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Browne, M. W., \& Cudeck, R. (1992). Alternative ways of assessing model fit. \emph{Sociological Methods \& Research, 21}, 230-258.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
path <- matrix(0, 4, 4)
path[3, 1:2] <- NA
path[4, 3] <- NA
pathVal <- matrix("", 4, 4)
pathVal[3, 1:2] <- "runif(1, 0.3, 0.5)"
pathVal[4, 3] <- "runif(1, 0.5, 0.7)"
pathMis <- matrix(0, 4, 4)
pathMis[4, 1:2] <- "runif(1, -0.1, 0.1)"
BE <- bind(path, pathVal, pathMis)

residual.error <- diag(4)
residual.error[1,2] <- residual.error[2,1] <- NA
RPS <- binds(residual.error, "rnorm(1, 0.3, 0.1)")

Path.Model <- model(RPS = RPS, BE = BE, modelType="Path")

# The number of replications in actual analysis should be much more than 5
ParamObject <- sim(5, n=200, Path.Model)

# Summarize the model misspecification that is specified in the 'pathMis' object
summaryMisspec(ParamObject)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryParam}{Provide summary of parameter estimates and standard error across replications}{summaryParam}
%
\begin{Description}\relax
This function will provide averages of parameter estimates, standard deviations of parameter estimates, averages of standard errors, and power of rejection with a priori alpha level for the null hypothesis of parameters equal 0.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryParam(object, alpha = 0.05, detail = FALSE, improper = FALSE, 
	digits = NULL, matchParam = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described

\item[\code{alpha}] 
The alpha level used to find the statistical power of each parameter estimate

\item[\code{detail}] 
If TRUE, more details about each parameter estimate are provided, such as relative bias, standardized bias, or relative standard error bias.

\item[\code{improper}] 
If TRUE, include the replications that provided improper solutions

\item[\code{digits}] 
The number of digits rounded in the result. If \code{NULL}, the results will not be rounded.

\item[\code{matchParam}] 
If \code{TRUE}, only parameter estimates that have the same names as the parameter values will be reported. This argument is recommended when users know that the data-generation model and analysis model are the same. Then the comparison between the parameter estimates and parameter value will be valid.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame that provides the statistics described above from all parameters.
For using with \code{linkS4class\{SimResult\}}, each column means
\begin{itemize}

\item \code{Estimate.Average:} Average of parameter estimates across all replications
\item \code{Estimate.SD:} Standard Deviation of parameter estimates across all replications
\item \code{Average.SE:} Average of standard errors across all replications
\item \code{Power (Not equal 0):} Proportion of significant replications when testing whether the parameters are different from zero. The alpha level can be set by the \code{alpha} argument of this function.
\item \code{Average.Param:} Parameter values or average values of parameters if random parameters are specified
\item \code{SD.Param:} Standard Deviations of parameters. Show only when random parameters are specified.
\item \code{Average.Bias:} The difference between parameter estimates and parameter underlying data
\item \code{SD.Bias:} Standard Deviations of bias across all replications. Show only when random parameters are specified. 
This value is the expected value of average standard error when random parameter are specified.
\item \code{Coverage:} The percentage of (1-alpha)\% confidence interval covers parameters underlying the data.
\item \code{Rel.Bias:} Relative Bias, which is (\code{Estimate.Average} - \code{Average.Param})/\code{Average.Param}. 
Hoogland and Boomsma (1998) proposed that the cutoff of .05 may be used for acceptable relative bias.
This option will be available when \code{detail=TRUE}. This value will not be available when parameter values are very close to 0.
\item \code{Std.Bias:} Standardized Bias, which is (\code{Estimate.Average} - \code{Average.Param})/\code{Estimate.SD} 
for fixed parameters and (\code{Estimate.Average} - \code{Average.Param})/\code{SD.Bias} 
for random parameters. Collins, Schafer, and Kam (2001) recommended that biases will be 
only noticeable when standardized bias is greater than 0.4 in magnitude.
This option will be available when \code{detail=TRUE}
\item \code{Rel.SE.Bias:} Relative Bias in standard error, which is (\code{Average.SE} - \code{Estimate.SD})/\code{Estimate.SD} 
for fixed parameters and (\code{Average.SE} - \code{SD.Bias})/\code{SD.Bias} 
for random parameters. 	Hoogland and Boomsma (1998) proposed that 0.10 is the acceptable level.
This option will be available when \code{detail=TRUE}
\item \code{Not Cover Below:} The percentage of (1-alpha)\% confidence interval does not cover the parameter and the parameter is below the confidence interval.
\item \code{Not Cover Above:} The percentage of (1-alpha)\% confidence interval does not cover the parameter and the parameter is above the confidence interval.
\item \code{Average CI Width:} The average of (1-alpha)\% confidence interval width across replications.
\item \code{SD CI Width:} The standard deviation of (1-alpha)\% confidence interval width across replications.

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{References}\relax
Collins, L. M., Schafer, J. L., \& Kam, C. M. (2001). A comparison of inclusive and restrictive strategies in modern missing data procedures. \emph{Psychological Methods, 6}, 330-351.

Hoogland, J. J., \& Boomsma, A. (1998). Robustness studies in covariance structure modeling. \emph{Sociological Methods \& Research, 26}, 329-367.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{SimResult}{SimResult.Rdash.class}} for the object input
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("SimResult")
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, 0.7)
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We make the examples running only 5 replications to save time.
# In reality, more replications are needed.
Output <- sim(5, n=500, CFA.Model)

# Summary of the parameter estimates
summaryParam(Output)

# Summary of the parameter estimates with additional details
summaryParam(Output, detail=TRUE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryPopulation}{Summarize the population model used for data generation underlying a result object}{summaryPopulation}
%
\begin{Description}\relax
Summarize the population model used for data generation underlying a result object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryPopulation(object, improper = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
The result object that you wish to extract the data generation population model from (\code{linkS4class\{SimResult\}}).

\item[\code{improper}] 
If TRUE, include the replications that provided improper solutions

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{data.frame} contianing the summary of population model across replications.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
\begin{itemize}

\item \code{\LinkA{SimResult}{SimResult.Rdash.class}} for result object

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 1)
loading[1:6, 1] <- NA
LY <- bind(loading, "runif(1, 0.4, 0.9)")
RPS <- binds(diag(1))
RTE <- binds(diag(6))
CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType="CFA")

# We will use only 10 replications to save time.
# In reality, more replications are needed.
Output <- sim(10, n=200, model=CFA.Model)

# Get the summary of population model
summaryPopulation(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summarySeed}{Summary of a seed number}{summarySeed}
%
\begin{Description}\relax
Summary of a seed number used in the simulation
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summarySeed(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The first section is the seed number used in running the whole simulation. The second section is the L'Ecuyer seed of the last replication.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model, n=200)
summarySeed(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryShort}{Provide short summary of an object.}{summaryShort}
\aliasA{summaryShort,ANY-method}{summaryShort}{summaryShort,ANY.Rdash.method}
\aliasA{summaryShort,matrix-method}{summaryShort}{summaryShort,matrix.Rdash.method}
\aliasA{summaryShort,vector-method}{summaryShort}{summaryShort,vector.Rdash.method}
\aliasA{summaryShort-methods}{summaryShort}{summaryShort.Rdash.methods}
%
\begin{Description}\relax
Provide short summary if it is available. Otherwise, it is an alias for \code{summary}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryShort(object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
Desired object being described

\item[\code{...}] 
any additional arguments

\end{ldescription}
\end{Arguments}
%
\begin{Value}
NONE. This function will print on screen only.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{SeeAlso}\relax
This is the list of classes that can use \code{summaryShort} method.
\begin{itemize}

\item \code{\LinkA{SimMatrix}{SimMatrix.Rdash.class}}
\item \code{\LinkA{SimVector}{SimVector.Rdash.class}}

\end{itemize}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
loadingValues <- matrix(0, 6, 2)
LY <- bind(loading, "runif(1, 0.8, 0.9)")
summaryShort(LY)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{summaryTime}{Time summary}{summaryTime}
%
\begin{Description}\relax
Provide a summary of time elapsed in running the simulation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
summaryTime(object, units = "seconds")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{\LinkA{SimResult}{SimResult.Rdash.class}} object being described

\item[\code{units}] 
The units of time, which can be "seconds", "minutes", "hours", or "days"

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The first section is the actual time used in each step of the simulation. The second section is the average system (processor) time used in each replication. The third section is the summary of starting time, end time, total actual time, and total system time.
\end{Value}
%
\begin{Author}\relax
Sunthud Pornprasertmanit (University of Kansas; \email{psunthud@ku.edu})
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
loading <- matrix(0, 6, 2)
loading[1:3, 1] <- NA
loading[4:6, 2] <- NA
LY <- bind(loading, 0.7)

latent.cor <- matrix(NA, 2, 2)
diag(latent.cor) <- 1
RPS <- binds(latent.cor, 0.5)

RTE <- binds(diag(6))

VY <- bind(rep(NA,6),2)

CFA.Model <- model(LY = LY, RPS = RPS, RTE = RTE, modelType = "CFA")

# In reality, more than 5 replications are needed.
Output <- sim(5, CFA.Model, n=200)
summaryTime(Output)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
